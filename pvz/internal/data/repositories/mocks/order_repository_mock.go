// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"context"
	"pvz-cli/internal/models"
	"pvz-cli/internal/usecases/requests"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepositoryMock implements mm_repositories.OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDelete          func(ctx context.Context, id uint64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id uint64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mOrderRepositoryMockDelete

	funcList          func(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, i1 int, err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, filter requests.OrdersFilterRequest)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mOrderRepositoryMockList

	funcLoad          func(ctx context.Context, id uint64) (o1 models.Order, err error)
	funcLoadOrigin    string
	inspectFuncLoad   func(ctx context.Context, id uint64)
	afterLoadCounter  uint64
	beforeLoadCounter uint64
	LoadMock          mOrderRepositoryMockLoad

	funcSave          func(ctx context.Context, order models.Order) (err error)
	funcSaveOrigin    string
	inspectFuncSave   func(ctx context.Context, order models.Order)
	afterSaveCounter  uint64
	beforeSaveCounter uint64
	SaveMock          mOrderRepositoryMockSave
}

// NewOrderRepositoryMock returns a mock for mm_repositories.OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mOrderRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*OrderRepositoryMockDeleteParams{}

	m.ListMock = mOrderRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*OrderRepositoryMockListParams{}

	m.LoadMock = mOrderRepositoryMockLoad{mock: m}
	m.LoadMock.callArgs = []*OrderRepositoryMockLoadParams{}

	m.SaveMock = mOrderRepositoryMockSave{mock: m}
	m.SaveMock.callArgs = []*OrderRepositoryMockSaveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockDelete struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockDeleteExpectation
	expectations       []*OrderRepositoryMockDeleteExpectation

	callArgs []*OrderRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockDeleteExpectation specifies expectation struct of the OrderRepository.Delete
type OrderRepositoryMockDeleteExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockDeleteParams
	paramPtrs          *OrderRepositoryMockDeleteParamPtrs
	expectationOrigins OrderRepositoryMockDeleteExpectationOrigins
	results            *OrderRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockDeleteParams contains parameters of the OrderRepository.Delete
type OrderRepositoryMockDeleteParams struct {
	ctx context.Context
	id  uint64
}

// OrderRepositoryMockDeleteParamPtrs contains pointers to parameters of the OrderRepository.Delete
type OrderRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *uint64
}

// OrderRepositoryMockDeleteResults contains results of the OrderRepository.Delete
type OrderRepositoryMockDeleteResults struct {
	err error
}

// OrderRepositoryMockDeleteOrigins contains origins of expectations of the OrderRepository.Delete
type OrderRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mOrderRepositoryMockDelete) Optional() *mOrderRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for OrderRepository.Delete
func (mmDelete *mOrderRepositoryMockDelete) Expect(ctx context.Context, id uint64) *mOrderRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &OrderRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Delete
func (mmDelete *mOrderRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for OrderRepository.Delete
func (mmDelete *mOrderRepositoryMockDelete) ExpectIdParam2(id uint64) *mOrderRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Delete
func (mmDelete *mOrderRepositoryMockDelete) Inspect(f func(ctx context.Context, id uint64)) *mOrderRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by OrderRepository.Delete
func (mmDelete *mOrderRepositoryMockDelete) Return(err error) *OrderRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &OrderRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the OrderRepository.Delete method
func (mmDelete *mOrderRepositoryMockDelete) Set(f func(ctx context.Context, id uint64) (err error)) *OrderRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the OrderRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mOrderRepositoryMockDelete) When(ctx context.Context, id uint64) *OrderRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &OrderRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &OrderRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: OrderRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.Delete return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockDeleteExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.Delete should be invoked
func (mmDelete *mOrderRepositoryMockDelete) Times(n uint64) *mOrderRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of OrderRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mOrderRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repositories.OrderRepository
func (mmDelete *OrderRepositoryMock) Delete(ctx context.Context, id uint64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := OrderRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("OrderRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("OrderRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("OrderRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the OrderRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to OrderRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished OrderRepositoryMock.Delete invocations
func (mmDelete *OrderRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of OrderRepositoryMock.Delete invocations
func (mmDelete *OrderRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mOrderRepositoryMockDelete) Calls() []*OrderRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mOrderRepositoryMockList struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockListExpectation
	expectations       []*OrderRepositoryMockListExpectation

	callArgs []*OrderRepositoryMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockListExpectation specifies expectation struct of the OrderRepository.List
type OrderRepositoryMockListExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockListParams
	paramPtrs          *OrderRepositoryMockListParamPtrs
	expectationOrigins OrderRepositoryMockListExpectationOrigins
	results            *OrderRepositoryMockListResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockListParams contains parameters of the OrderRepository.List
type OrderRepositoryMockListParams struct {
	ctx    context.Context
	filter requests.OrdersFilterRequest
}

// OrderRepositoryMockListParamPtrs contains pointers to parameters of the OrderRepository.List
type OrderRepositoryMockListParamPtrs struct {
	ctx    *context.Context
	filter *requests.OrdersFilterRequest
}

// OrderRepositoryMockListResults contains results of the OrderRepository.List
type OrderRepositoryMockListResults struct {
	oa1 []models.Order
	i1  int
	err error
}

// OrderRepositoryMockListOrigins contains origins of expectations of the OrderRepository.List
type OrderRepositoryMockListExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mOrderRepositoryMockList) Optional() *mOrderRepositoryMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for OrderRepository.List
func (mmList *mOrderRepositoryMockList) Expect(ctx context.Context, filter requests.OrdersFilterRequest) *mOrderRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &OrderRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &OrderRepositoryMockListParams{ctx, filter}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.List
func (mmList *mOrderRepositoryMockList) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &OrderRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &OrderRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectFilterParam2 sets up expected param filter for OrderRepository.List
func (mmList *mOrderRepositoryMockList) ExpectFilterParam2(filter requests.OrdersFilterRequest) *mOrderRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &OrderRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &OrderRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.filter = &filter
	mmList.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.List
func (mmList *mOrderRepositoryMockList) Inspect(f func(ctx context.Context, filter requests.OrdersFilterRequest)) *mOrderRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by OrderRepository.List
func (mmList *mOrderRepositoryMockList) Return(oa1 []models.Order, i1 int, err error) *OrderRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &OrderRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &OrderRepositoryMockListResults{oa1, i1, err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the OrderRepository.List method
func (mmList *mOrderRepositoryMockList) Set(f func(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, i1 int, err error)) *OrderRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the OrderRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the OrderRepository.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the OrderRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mOrderRepositoryMockList) When(ctx context.Context, filter requests.OrdersFilterRequest) *OrderRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("OrderRepositoryMock.List mock is already set by Set")
	}

	expectation := &OrderRepositoryMockListExpectation{
		mock:               mmList.mock,
		params:             &OrderRepositoryMockListParams{ctx, filter},
		expectationOrigins: OrderRepositoryMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.List return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockListExpectation) Then(oa1 []models.Order, i1 int, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockListResults{oa1, i1, err}
	return e.mock
}

// Times sets number of times OrderRepository.List should be invoked
func (mmList *mOrderRepositoryMockList) Times(n uint64) *mOrderRepositoryMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of OrderRepositoryMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mOrderRepositoryMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_repositories.OrderRepository
func (mmList *OrderRepositoryMock) List(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, i1 int, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, filter)
	}

	mm_params := OrderRepositoryMockListParams{ctx, filter}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.i1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockListParams{ctx, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("OrderRepositoryMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmList.t.Errorf("OrderRepositoryMock.List got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("OrderRepositoryMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the OrderRepositoryMock.List")
		}
		return (*mm_results).oa1, (*mm_results).i1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, filter)
	}
	mmList.t.Fatalf("Unexpected call to OrderRepositoryMock.List. %v %v", ctx, filter)
	return
}

// ListAfterCounter returns a count of finished OrderRepositoryMock.List invocations
func (mmList *OrderRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of OrderRepositoryMock.List invocations
func (mmList *OrderRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mOrderRepositoryMockList) Calls() []*OrderRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mOrderRepositoryMockLoad struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockLoadExpectation
	expectations       []*OrderRepositoryMockLoadExpectation

	callArgs []*OrderRepositoryMockLoadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockLoadExpectation specifies expectation struct of the OrderRepository.Load
type OrderRepositoryMockLoadExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockLoadParams
	paramPtrs          *OrderRepositoryMockLoadParamPtrs
	expectationOrigins OrderRepositoryMockLoadExpectationOrigins
	results            *OrderRepositoryMockLoadResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockLoadParams contains parameters of the OrderRepository.Load
type OrderRepositoryMockLoadParams struct {
	ctx context.Context
	id  uint64
}

// OrderRepositoryMockLoadParamPtrs contains pointers to parameters of the OrderRepository.Load
type OrderRepositoryMockLoadParamPtrs struct {
	ctx *context.Context
	id  *uint64
}

// OrderRepositoryMockLoadResults contains results of the OrderRepository.Load
type OrderRepositoryMockLoadResults struct {
	o1  models.Order
	err error
}

// OrderRepositoryMockLoadOrigins contains origins of expectations of the OrderRepository.Load
type OrderRepositoryMockLoadExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoad *mOrderRepositoryMockLoad) Optional() *mOrderRepositoryMockLoad {
	mmLoad.optional = true
	return mmLoad
}

// Expect sets up expected params for OrderRepository.Load
func (mmLoad *mOrderRepositoryMockLoad) Expect(ctx context.Context, id uint64) *mOrderRepositoryMockLoad {
	if mmLoad.mock.funcLoad != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by Set")
	}

	if mmLoad.defaultExpectation == nil {
		mmLoad.defaultExpectation = &OrderRepositoryMockLoadExpectation{}
	}

	if mmLoad.defaultExpectation.paramPtrs != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by ExpectParams functions")
	}

	mmLoad.defaultExpectation.params = &OrderRepositoryMockLoadParams{ctx, id}
	mmLoad.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLoad.expectations {
		if minimock.Equal(e.params, mmLoad.defaultExpectation.params) {
			mmLoad.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoad.defaultExpectation.params)
		}
	}

	return mmLoad
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Load
func (mmLoad *mOrderRepositoryMockLoad) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockLoad {
	if mmLoad.mock.funcLoad != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by Set")
	}

	if mmLoad.defaultExpectation == nil {
		mmLoad.defaultExpectation = &OrderRepositoryMockLoadExpectation{}
	}

	if mmLoad.defaultExpectation.params != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by Expect")
	}

	if mmLoad.defaultExpectation.paramPtrs == nil {
		mmLoad.defaultExpectation.paramPtrs = &OrderRepositoryMockLoadParamPtrs{}
	}
	mmLoad.defaultExpectation.paramPtrs.ctx = &ctx
	mmLoad.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLoad
}

// ExpectIdParam2 sets up expected param id for OrderRepository.Load
func (mmLoad *mOrderRepositoryMockLoad) ExpectIdParam2(id uint64) *mOrderRepositoryMockLoad {
	if mmLoad.mock.funcLoad != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by Set")
	}

	if mmLoad.defaultExpectation == nil {
		mmLoad.defaultExpectation = &OrderRepositoryMockLoadExpectation{}
	}

	if mmLoad.defaultExpectation.params != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by Expect")
	}

	if mmLoad.defaultExpectation.paramPtrs == nil {
		mmLoad.defaultExpectation.paramPtrs = &OrderRepositoryMockLoadParamPtrs{}
	}
	mmLoad.defaultExpectation.paramPtrs.id = &id
	mmLoad.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmLoad
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Load
func (mmLoad *mOrderRepositoryMockLoad) Inspect(f func(ctx context.Context, id uint64)) *mOrderRepositoryMockLoad {
	if mmLoad.mock.inspectFuncLoad != nil {
		mmLoad.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Load")
	}

	mmLoad.mock.inspectFuncLoad = f

	return mmLoad
}

// Return sets up results that will be returned by OrderRepository.Load
func (mmLoad *mOrderRepositoryMockLoad) Return(o1 models.Order, err error) *OrderRepositoryMock {
	if mmLoad.mock.funcLoad != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by Set")
	}

	if mmLoad.defaultExpectation == nil {
		mmLoad.defaultExpectation = &OrderRepositoryMockLoadExpectation{mock: mmLoad.mock}
	}
	mmLoad.defaultExpectation.results = &OrderRepositoryMockLoadResults{o1, err}
	mmLoad.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLoad.mock
}

// Set uses given function f to mock the OrderRepository.Load method
func (mmLoad *mOrderRepositoryMockLoad) Set(f func(ctx context.Context, id uint64) (o1 models.Order, err error)) *OrderRepositoryMock {
	if mmLoad.defaultExpectation != nil {
		mmLoad.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Load method")
	}

	if len(mmLoad.expectations) > 0 {
		mmLoad.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Load method")
	}

	mmLoad.mock.funcLoad = f
	mmLoad.mock.funcLoadOrigin = minimock.CallerInfo(1)
	return mmLoad.mock
}

// When sets expectation for the OrderRepository.Load which will trigger the result defined by the following
// Then helper
func (mmLoad *mOrderRepositoryMockLoad) When(ctx context.Context, id uint64) *OrderRepositoryMockLoadExpectation {
	if mmLoad.mock.funcLoad != nil {
		mmLoad.mock.t.Fatalf("OrderRepositoryMock.Load mock is already set by Set")
	}

	expectation := &OrderRepositoryMockLoadExpectation{
		mock:               mmLoad.mock,
		params:             &OrderRepositoryMockLoadParams{ctx, id},
		expectationOrigins: OrderRepositoryMockLoadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLoad.expectations = append(mmLoad.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.Load return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockLoadExpectation) Then(o1 models.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockLoadResults{o1, err}
	return e.mock
}

// Times sets number of times OrderRepository.Load should be invoked
func (mmLoad *mOrderRepositoryMockLoad) Times(n uint64) *mOrderRepositoryMockLoad {
	if n == 0 {
		mmLoad.mock.t.Fatalf("Times of OrderRepositoryMock.Load mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoad.expectedInvocations, n)
	mmLoad.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLoad
}

func (mmLoad *mOrderRepositoryMockLoad) invocationsDone() bool {
	if len(mmLoad.expectations) == 0 && mmLoad.defaultExpectation == nil && mmLoad.mock.funcLoad == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoad.mock.afterLoadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoad.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Load implements mm_repositories.OrderRepository
func (mmLoad *OrderRepositoryMock) Load(ctx context.Context, id uint64) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmLoad.beforeLoadCounter, 1)
	defer mm_atomic.AddUint64(&mmLoad.afterLoadCounter, 1)

	mmLoad.t.Helper()

	if mmLoad.inspectFuncLoad != nil {
		mmLoad.inspectFuncLoad(ctx, id)
	}

	mm_params := OrderRepositoryMockLoadParams{ctx, id}

	// Record call args
	mmLoad.LoadMock.mutex.Lock()
	mmLoad.LoadMock.callArgs = append(mmLoad.LoadMock.callArgs, &mm_params)
	mmLoad.LoadMock.mutex.Unlock()

	for _, e := range mmLoad.LoadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmLoad.LoadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoad.LoadMock.defaultExpectation.Counter, 1)
		mm_want := mmLoad.LoadMock.defaultExpectation.params
		mm_want_ptrs := mmLoad.LoadMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockLoadParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoad.t.Errorf("OrderRepositoryMock.Load got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoad.LoadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmLoad.t.Errorf("OrderRepositoryMock.Load got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLoad.LoadMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoad.t.Errorf("OrderRepositoryMock.Load got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLoad.LoadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoad.LoadMock.defaultExpectation.results
		if mm_results == nil {
			mmLoad.t.Fatal("No results are set for the OrderRepositoryMock.Load")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmLoad.funcLoad != nil {
		return mmLoad.funcLoad(ctx, id)
	}
	mmLoad.t.Fatalf("Unexpected call to OrderRepositoryMock.Load. %v %v", ctx, id)
	return
}

// LoadAfterCounter returns a count of finished OrderRepositoryMock.Load invocations
func (mmLoad *OrderRepositoryMock) LoadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoad.afterLoadCounter)
}

// LoadBeforeCounter returns a count of OrderRepositoryMock.Load invocations
func (mmLoad *OrderRepositoryMock) LoadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoad.beforeLoadCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Load.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoad *mOrderRepositoryMockLoad) Calls() []*OrderRepositoryMockLoadParams {
	mmLoad.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockLoadParams, len(mmLoad.callArgs))
	copy(argCopy, mmLoad.callArgs)

	mmLoad.mutex.RUnlock()

	return argCopy
}

// MinimockLoadDone returns true if the count of the Load invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockLoadDone() bool {
	if m.LoadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadMock.invocationsDone()
}

// MinimockLoadInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockLoadInspect() {
	for _, e := range m.LoadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Load at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoadCounter := mm_atomic.LoadUint64(&m.afterLoadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadMock.defaultExpectation != nil && afterLoadCounter < 1 {
		if m.LoadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Load at\n%s", m.LoadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Load at\n%s with params: %#v", m.LoadMock.defaultExpectation.expectationOrigins.origin, *m.LoadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoad != nil && afterLoadCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Load at\n%s", m.funcLoadOrigin)
	}

	if !m.LoadMock.invocationsDone() && afterLoadCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Load at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoadMock.expectedInvocations), m.LoadMock.expectedInvocationsOrigin, afterLoadCounter)
	}
}

type mOrderRepositoryMockSave struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSaveExpectation
	expectations       []*OrderRepositoryMockSaveExpectation

	callArgs []*OrderRepositoryMockSaveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockSaveExpectation specifies expectation struct of the OrderRepository.Save
type OrderRepositoryMockSaveExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockSaveParams
	paramPtrs          *OrderRepositoryMockSaveParamPtrs
	expectationOrigins OrderRepositoryMockSaveExpectationOrigins
	results            *OrderRepositoryMockSaveResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockSaveParams contains parameters of the OrderRepository.Save
type OrderRepositoryMockSaveParams struct {
	ctx   context.Context
	order models.Order
}

// OrderRepositoryMockSaveParamPtrs contains pointers to parameters of the OrderRepository.Save
type OrderRepositoryMockSaveParamPtrs struct {
	ctx   *context.Context
	order *models.Order
}

// OrderRepositoryMockSaveResults contains results of the OrderRepository.Save
type OrderRepositoryMockSaveResults struct {
	err error
}

// OrderRepositoryMockSaveOrigins contains origins of expectations of the OrderRepository.Save
type OrderRepositoryMockSaveExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSave *mOrderRepositoryMockSave) Optional() *mOrderRepositoryMockSave {
	mmSave.optional = true
	return mmSave
}

// Expect sets up expected params for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Expect(ctx context.Context, order models.Order) *mOrderRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.paramPtrs != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by ExpectParams functions")
	}

	mmSave.defaultExpectation.params = &OrderRepositoryMockSaveParams{ctx, order}
	mmSave.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSave.expectations {
		if minimock.Equal(e.params, mmSave.defaultExpectation.params) {
			mmSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSave.defaultExpectation.params)
		}
	}

	return mmSave
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.ctx = &ctx
	mmSave.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSave
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) ExpectOrderParam2(order models.Order) *mOrderRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.order = &order
	mmSave.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmSave
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Inspect(f func(ctx context.Context, order models.Order)) *mOrderRepositoryMockSave {
	if mmSave.mock.inspectFuncSave != nil {
		mmSave.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Save")
	}

	mmSave.mock.inspectFuncSave = f

	return mmSave
}

// Return sets up results that will be returned by OrderRepository.Save
func (mmSave *mOrderRepositoryMockSave) Return(err error) *OrderRepositoryMock {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &OrderRepositoryMockSaveExpectation{mock: mmSave.mock}
	}
	mmSave.defaultExpectation.results = &OrderRepositoryMockSaveResults{err}
	mmSave.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// Set uses given function f to mock the OrderRepository.Save method
func (mmSave *mOrderRepositoryMockSave) Set(f func(ctx context.Context, order models.Order) (err error)) *OrderRepositoryMock {
	if mmSave.defaultExpectation != nil {
		mmSave.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Save method")
	}

	if len(mmSave.expectations) > 0 {
		mmSave.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Save method")
	}

	mmSave.mock.funcSave = f
	mmSave.mock.funcSaveOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// When sets expectation for the OrderRepository.Save which will trigger the result defined by the following
// Then helper
func (mmSave *mOrderRepositoryMockSave) When(ctx context.Context, order models.Order) *OrderRepositoryMockSaveExpectation {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("OrderRepositoryMock.Save mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSaveExpectation{
		mock:               mmSave.mock,
		params:             &OrderRepositoryMockSaveParams{ctx, order},
		expectationOrigins: OrderRepositoryMockSaveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSave.expectations = append(mmSave.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.Save return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSaveExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSaveResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.Save should be invoked
func (mmSave *mOrderRepositoryMockSave) Times(n uint64) *mOrderRepositoryMockSave {
	if n == 0 {
		mmSave.mock.t.Fatalf("Times of OrderRepositoryMock.Save mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSave.expectedInvocations, n)
	mmSave.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSave
}

func (mmSave *mOrderRepositoryMockSave) invocationsDone() bool {
	if len(mmSave.expectations) == 0 && mmSave.defaultExpectation == nil && mmSave.mock.funcSave == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSave.mock.afterSaveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSave.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Save implements mm_repositories.OrderRepository
func (mmSave *OrderRepositoryMock) Save(ctx context.Context, order models.Order) (err error) {
	mm_atomic.AddUint64(&mmSave.beforeSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmSave.afterSaveCounter, 1)

	mmSave.t.Helper()

	if mmSave.inspectFuncSave != nil {
		mmSave.inspectFuncSave(ctx, order)
	}

	mm_params := OrderRepositoryMockSaveParams{ctx, order}

	// Record call args
	mmSave.SaveMock.mutex.Lock()
	mmSave.SaveMock.callArgs = append(mmSave.SaveMock.callArgs, &mm_params)
	mmSave.SaveMock.mutex.Unlock()

	for _, e := range mmSave.SaveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSave.SaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSave.SaveMock.defaultExpectation.Counter, 1)
		mm_want := mmSave.SaveMock.defaultExpectation.params
		mm_want_ptrs := mmSave.SaveMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSaveParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSave.t.Errorf("OrderRepositoryMock.Save got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSave.SaveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSave.SaveMock.defaultExpectation.results
		if mm_results == nil {
			mmSave.t.Fatal("No results are set for the OrderRepositoryMock.Save")
		}
		return (*mm_results).err
	}
	if mmSave.funcSave != nil {
		return mmSave.funcSave(ctx, order)
	}
	mmSave.t.Fatalf("Unexpected call to OrderRepositoryMock.Save. %v %v", ctx, order)
	return
}

// SaveAfterCounter returns a count of finished OrderRepositoryMock.Save invocations
func (mmSave *OrderRepositoryMock) SaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.afterSaveCounter)
}

// SaveBeforeCounter returns a count of OrderRepositoryMock.Save invocations
func (mmSave *OrderRepositoryMock) SaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.beforeSaveCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Save.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSave *mOrderRepositoryMockSave) Calls() []*OrderRepositoryMockSaveParams {
	mmSave.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSaveParams, len(mmSave.callArgs))
	copy(argCopy, mmSave.callArgs)

	mmSave.mutex.RUnlock()

	return argCopy
}

// MinimockSaveDone returns true if the count of the Save invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSaveDone() bool {
	if m.SaveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveMock.invocationsDone()
}

// MinimockSaveInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSaveInspect() {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveCounter := mm_atomic.LoadUint64(&m.afterSaveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && afterSaveCounter < 1 {
		if m.SaveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s", m.SaveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s with params: %#v", m.SaveMock.defaultExpectation.expectationOrigins.origin, *m.SaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && afterSaveCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Save at\n%s", m.funcSaveOrigin)
	}

	if !m.SaveMock.invocationsDone() && afterSaveCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Save at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveMock.expectedInvocations), m.SaveMock.expectedInvocationsOrigin, afterSaveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteInspect()

			m.MinimockListInspect()

			m.MinimockLoadInspect()

			m.MinimockSaveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockListDone() &&
		m.MinimockLoadDone() &&
		m.MinimockSaveDone()
}
