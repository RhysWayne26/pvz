// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"context"
	"pvz-cli/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OutboxRepositoryMock implements mm_repositories.OutboxRepository
type OutboxRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, eventID uint64, payload []byte) (err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, eventID uint64, payload []byte)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOutboxRepositoryMockCreate

	funcGetProcessingEvents          func(ctx context.Context, limit int, retryDelay time.Duration) (oa1 []models.OutboxEvent, err error)
	funcGetProcessingEventsOrigin    string
	inspectFuncGetProcessingEvents   func(ctx context.Context, limit int, retryDelay time.Duration)
	afterGetProcessingEventsCounter  uint64
	beforeGetProcessingEventsCounter uint64
	GetProcessingEventsMock          mOutboxRepositoryMockGetProcessingEvents

	funcSetCompleted          func(ctx context.Context, eventID uint64, sentAt time.Time) (err error)
	funcSetCompletedOrigin    string
	inspectFuncSetCompleted   func(ctx context.Context, eventID uint64, sentAt time.Time)
	afterSetCompletedCounter  uint64
	beforeSetCompletedCounter uint64
	SetCompletedMock          mOutboxRepositoryMockSetCompleted

	funcSetFailed          func(ctx context.Context, eventID uint64, errMsg string) (err error)
	funcSetFailedOrigin    string
	inspectFuncSetFailed   func(ctx context.Context, eventID uint64, errMsg string)
	afterSetFailedCounter  uint64
	beforeSetFailedCounter uint64
	SetFailedMock          mOutboxRepositoryMockSetFailed

	funcSetProcessing          func(ctx context.Context, limit int, retryDelay time.Duration) (err error)
	funcSetProcessingOrigin    string
	inspectFuncSetProcessing   func(ctx context.Context, limit int, retryDelay time.Duration)
	afterSetProcessingCounter  uint64
	beforeSetProcessingCounter uint64
	SetProcessingMock          mOutboxRepositoryMockSetProcessing

	funcUpdateError          func(ctx context.Context, eventID uint64, errMsg string) (err error)
	funcUpdateErrorOrigin    string
	inspectFuncUpdateError   func(ctx context.Context, eventID uint64, errMsg string)
	afterUpdateErrorCounter  uint64
	beforeUpdateErrorCounter uint64
	UpdateErrorMock          mOutboxRepositoryMockUpdateError
}

// NewOutboxRepositoryMock returns a mock for mm_repositories.OutboxRepository
func NewOutboxRepositoryMock(t minimock.Tester) *OutboxRepositoryMock {
	m := &OutboxRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOutboxRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*OutboxRepositoryMockCreateParams{}

	m.GetProcessingEventsMock = mOutboxRepositoryMockGetProcessingEvents{mock: m}
	m.GetProcessingEventsMock.callArgs = []*OutboxRepositoryMockGetProcessingEventsParams{}

	m.SetCompletedMock = mOutboxRepositoryMockSetCompleted{mock: m}
	m.SetCompletedMock.callArgs = []*OutboxRepositoryMockSetCompletedParams{}

	m.SetFailedMock = mOutboxRepositoryMockSetFailed{mock: m}
	m.SetFailedMock.callArgs = []*OutboxRepositoryMockSetFailedParams{}

	m.SetProcessingMock = mOutboxRepositoryMockSetProcessing{mock: m}
	m.SetProcessingMock.callArgs = []*OutboxRepositoryMockSetProcessingParams{}

	m.UpdateErrorMock = mOutboxRepositoryMockUpdateError{mock: m}
	m.UpdateErrorMock.callArgs = []*OutboxRepositoryMockUpdateErrorParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOutboxRepositoryMockCreate struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockCreateExpectation
	expectations       []*OutboxRepositoryMockCreateExpectation

	callArgs []*OutboxRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockCreateExpectation specifies expectation struct of the OutboxRepository.Create
type OutboxRepositoryMockCreateExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockCreateParams
	paramPtrs          *OutboxRepositoryMockCreateParamPtrs
	expectationOrigins OutboxRepositoryMockCreateExpectationOrigins
	results            *OutboxRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockCreateParams contains parameters of the OutboxRepository.Create
type OutboxRepositoryMockCreateParams struct {
	ctx     context.Context
	eventID uint64
	payload []byte
}

// OutboxRepositoryMockCreateParamPtrs contains pointers to parameters of the OutboxRepository.Create
type OutboxRepositoryMockCreateParamPtrs struct {
	ctx     *context.Context
	eventID *uint64
	payload *[]byte
}

// OutboxRepositoryMockCreateResults contains results of the OutboxRepository.Create
type OutboxRepositoryMockCreateResults struct {
	err error
}

// OutboxRepositoryMockCreateOrigins contains origins of expectations of the OutboxRepository.Create
type OutboxRepositoryMockCreateExpectationOrigins struct {
	origin        string
	originCtx     string
	originEventID string
	originPayload string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOutboxRepositoryMockCreate) Optional() *mOutboxRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) Expect(ctx context.Context, eventID uint64, payload []byte) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OutboxRepositoryMockCreateParams{ctx, eventID, payload}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OutboxRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectEventIDParam2 sets up expected param eventID for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) ExpectEventIDParam2(eventID uint64) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OutboxRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.eventID = &eventID
	mmCreate.defaultExpectation.expectationOrigins.originEventID = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectPayloadParam3 sets up expected param payload for OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) ExpectPayloadParam3(payload []byte) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OutboxRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.payload = &payload
	mmCreate.defaultExpectation.expectationOrigins.originPayload = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) Inspect(f func(ctx context.Context, eventID uint64, payload []byte)) *mOutboxRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OutboxRepository.Create
func (mmCreate *mOutboxRepositoryMockCreate) Return(err error) *OutboxRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OutboxRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OutboxRepositoryMockCreateResults{err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the OutboxRepository.Create method
func (mmCreate *mOutboxRepositoryMockCreate) Set(f func(ctx context.Context, eventID uint64, payload []byte) (err error)) *OutboxRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the OutboxRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOutboxRepositoryMockCreate) When(ctx context.Context, eventID uint64, payload []byte) *OutboxRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OutboxRepositoryMock.Create mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OutboxRepositoryMockCreateParams{ctx, eventID, payload},
		expectationOrigins: OutboxRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.Create return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockCreateExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockCreateResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.Create should be invoked
func (mmCreate *mOutboxRepositoryMockCreate) Times(n uint64) *mOutboxRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OutboxRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOutboxRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repositories.OutboxRepository
func (mmCreate *OutboxRepositoryMock) Create(ctx context.Context, eventID uint64, payload []byte) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, eventID, payload)
	}

	mm_params := OutboxRepositoryMockCreateParams{ctx, eventID, payload}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockCreateParams{ctx, eventID, payload}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.eventID != nil && !minimock.Equal(*mm_want_ptrs.eventID, mm_got.eventID) {
				mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameter eventID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originEventID, *mm_want_ptrs.eventID, mm_got.eventID, minimock.Diff(*mm_want_ptrs.eventID, mm_got.eventID))
			}

			if mm_want_ptrs.payload != nil && !minimock.Equal(*mm_want_ptrs.payload, mm_got.payload) {
				mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameter payload, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originPayload, *mm_want_ptrs.payload, mm_got.payload, minimock.Diff(*mm_want_ptrs.payload, mm_got.payload))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OutboxRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OutboxRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, eventID, payload)
	}
	mmCreate.t.Fatalf("Unexpected call to OutboxRepositoryMock.Create. %v %v %v", ctx, eventID, payload)
	return
}

// CreateAfterCounter returns a count of finished OutboxRepositoryMock.Create invocations
func (mmCreate *OutboxRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OutboxRepositoryMock.Create invocations
func (mmCreate *OutboxRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOutboxRepositoryMockCreate) Calls() []*OutboxRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOutboxRepositoryMockGetProcessingEvents struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockGetProcessingEventsExpectation
	expectations       []*OutboxRepositoryMockGetProcessingEventsExpectation

	callArgs []*OutboxRepositoryMockGetProcessingEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockGetProcessingEventsExpectation specifies expectation struct of the OutboxRepository.GetProcessingEvents
type OutboxRepositoryMockGetProcessingEventsExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockGetProcessingEventsParams
	paramPtrs          *OutboxRepositoryMockGetProcessingEventsParamPtrs
	expectationOrigins OutboxRepositoryMockGetProcessingEventsExpectationOrigins
	results            *OutboxRepositoryMockGetProcessingEventsResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockGetProcessingEventsParams contains parameters of the OutboxRepository.GetProcessingEvents
type OutboxRepositoryMockGetProcessingEventsParams struct {
	ctx        context.Context
	limit      int
	retryDelay time.Duration
}

// OutboxRepositoryMockGetProcessingEventsParamPtrs contains pointers to parameters of the OutboxRepository.GetProcessingEvents
type OutboxRepositoryMockGetProcessingEventsParamPtrs struct {
	ctx        *context.Context
	limit      *int
	retryDelay *time.Duration
}

// OutboxRepositoryMockGetProcessingEventsResults contains results of the OutboxRepository.GetProcessingEvents
type OutboxRepositoryMockGetProcessingEventsResults struct {
	oa1 []models.OutboxEvent
	err error
}

// OutboxRepositoryMockGetProcessingEventsOrigins contains origins of expectations of the OutboxRepository.GetProcessingEvents
type OutboxRepositoryMockGetProcessingEventsExpectationOrigins struct {
	origin           string
	originCtx        string
	originLimit      string
	originRetryDelay string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) Optional() *mOutboxRepositoryMockGetProcessingEvents {
	mmGetProcessingEvents.optional = true
	return mmGetProcessingEvents
}

// Expect sets up expected params for OutboxRepository.GetProcessingEvents
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) Expect(ctx context.Context, limit int, retryDelay time.Duration) *mOutboxRepositoryMockGetProcessingEvents {
	if mmGetProcessingEvents.mock.funcGetProcessingEvents != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Set")
	}

	if mmGetProcessingEvents.defaultExpectation == nil {
		mmGetProcessingEvents.defaultExpectation = &OutboxRepositoryMockGetProcessingEventsExpectation{}
	}

	if mmGetProcessingEvents.defaultExpectation.paramPtrs != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by ExpectParams functions")
	}

	mmGetProcessingEvents.defaultExpectation.params = &OutboxRepositoryMockGetProcessingEventsParams{ctx, limit, retryDelay}
	mmGetProcessingEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetProcessingEvents.expectations {
		if minimock.Equal(e.params, mmGetProcessingEvents.defaultExpectation.params) {
			mmGetProcessingEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProcessingEvents.defaultExpectation.params)
		}
	}

	return mmGetProcessingEvents
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.GetProcessingEvents
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockGetProcessingEvents {
	if mmGetProcessingEvents.mock.funcGetProcessingEvents != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Set")
	}

	if mmGetProcessingEvents.defaultExpectation == nil {
		mmGetProcessingEvents.defaultExpectation = &OutboxRepositoryMockGetProcessingEventsExpectation{}
	}

	if mmGetProcessingEvents.defaultExpectation.params != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Expect")
	}

	if mmGetProcessingEvents.defaultExpectation.paramPtrs == nil {
		mmGetProcessingEvents.defaultExpectation.paramPtrs = &OutboxRepositoryMockGetProcessingEventsParamPtrs{}
	}
	mmGetProcessingEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetProcessingEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetProcessingEvents
}

// ExpectLimitParam2 sets up expected param limit for OutboxRepository.GetProcessingEvents
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) ExpectLimitParam2(limit int) *mOutboxRepositoryMockGetProcessingEvents {
	if mmGetProcessingEvents.mock.funcGetProcessingEvents != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Set")
	}

	if mmGetProcessingEvents.defaultExpectation == nil {
		mmGetProcessingEvents.defaultExpectation = &OutboxRepositoryMockGetProcessingEventsExpectation{}
	}

	if mmGetProcessingEvents.defaultExpectation.params != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Expect")
	}

	if mmGetProcessingEvents.defaultExpectation.paramPtrs == nil {
		mmGetProcessingEvents.defaultExpectation.paramPtrs = &OutboxRepositoryMockGetProcessingEventsParamPtrs{}
	}
	mmGetProcessingEvents.defaultExpectation.paramPtrs.limit = &limit
	mmGetProcessingEvents.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetProcessingEvents
}

// ExpectRetryDelayParam3 sets up expected param retryDelay for OutboxRepository.GetProcessingEvents
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) ExpectRetryDelayParam3(retryDelay time.Duration) *mOutboxRepositoryMockGetProcessingEvents {
	if mmGetProcessingEvents.mock.funcGetProcessingEvents != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Set")
	}

	if mmGetProcessingEvents.defaultExpectation == nil {
		mmGetProcessingEvents.defaultExpectation = &OutboxRepositoryMockGetProcessingEventsExpectation{}
	}

	if mmGetProcessingEvents.defaultExpectation.params != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Expect")
	}

	if mmGetProcessingEvents.defaultExpectation.paramPtrs == nil {
		mmGetProcessingEvents.defaultExpectation.paramPtrs = &OutboxRepositoryMockGetProcessingEventsParamPtrs{}
	}
	mmGetProcessingEvents.defaultExpectation.paramPtrs.retryDelay = &retryDelay
	mmGetProcessingEvents.defaultExpectation.expectationOrigins.originRetryDelay = minimock.CallerInfo(1)

	return mmGetProcessingEvents
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.GetProcessingEvents
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) Inspect(f func(ctx context.Context, limit int, retryDelay time.Duration)) *mOutboxRepositoryMockGetProcessingEvents {
	if mmGetProcessingEvents.mock.inspectFuncGetProcessingEvents != nil {
		mmGetProcessingEvents.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.GetProcessingEvents")
	}

	mmGetProcessingEvents.mock.inspectFuncGetProcessingEvents = f

	return mmGetProcessingEvents
}

// Return sets up results that will be returned by OutboxRepository.GetProcessingEvents
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) Return(oa1 []models.OutboxEvent, err error) *OutboxRepositoryMock {
	if mmGetProcessingEvents.mock.funcGetProcessingEvents != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Set")
	}

	if mmGetProcessingEvents.defaultExpectation == nil {
		mmGetProcessingEvents.defaultExpectation = &OutboxRepositoryMockGetProcessingEventsExpectation{mock: mmGetProcessingEvents.mock}
	}
	mmGetProcessingEvents.defaultExpectation.results = &OutboxRepositoryMockGetProcessingEventsResults{oa1, err}
	mmGetProcessingEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetProcessingEvents.mock
}

// Set uses given function f to mock the OutboxRepository.GetProcessingEvents method
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) Set(f func(ctx context.Context, limit int, retryDelay time.Duration) (oa1 []models.OutboxEvent, err error)) *OutboxRepositoryMock {
	if mmGetProcessingEvents.defaultExpectation != nil {
		mmGetProcessingEvents.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.GetProcessingEvents method")
	}

	if len(mmGetProcessingEvents.expectations) > 0 {
		mmGetProcessingEvents.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.GetProcessingEvents method")
	}

	mmGetProcessingEvents.mock.funcGetProcessingEvents = f
	mmGetProcessingEvents.mock.funcGetProcessingEventsOrigin = minimock.CallerInfo(1)
	return mmGetProcessingEvents.mock
}

// When sets expectation for the OutboxRepository.GetProcessingEvents which will trigger the result defined by the following
// Then helper
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) When(ctx context.Context, limit int, retryDelay time.Duration) *OutboxRepositoryMockGetProcessingEventsExpectation {
	if mmGetProcessingEvents.mock.funcGetProcessingEvents != nil {
		mmGetProcessingEvents.mock.t.Fatalf("OutboxRepositoryMock.GetProcessingEvents mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockGetProcessingEventsExpectation{
		mock:               mmGetProcessingEvents.mock,
		params:             &OutboxRepositoryMockGetProcessingEventsParams{ctx, limit, retryDelay},
		expectationOrigins: OutboxRepositoryMockGetProcessingEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetProcessingEvents.expectations = append(mmGetProcessingEvents.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.GetProcessingEvents return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockGetProcessingEventsExpectation) Then(oa1 []models.OutboxEvent, err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockGetProcessingEventsResults{oa1, err}
	return e.mock
}

// Times sets number of times OutboxRepository.GetProcessingEvents should be invoked
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) Times(n uint64) *mOutboxRepositoryMockGetProcessingEvents {
	if n == 0 {
		mmGetProcessingEvents.mock.t.Fatalf("Times of OutboxRepositoryMock.GetProcessingEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetProcessingEvents.expectedInvocations, n)
	mmGetProcessingEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetProcessingEvents
}

func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) invocationsDone() bool {
	if len(mmGetProcessingEvents.expectations) == 0 && mmGetProcessingEvents.defaultExpectation == nil && mmGetProcessingEvents.mock.funcGetProcessingEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetProcessingEvents.mock.afterGetProcessingEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetProcessingEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetProcessingEvents implements mm_repositories.OutboxRepository
func (mmGetProcessingEvents *OutboxRepositoryMock) GetProcessingEvents(ctx context.Context, limit int, retryDelay time.Duration) (oa1 []models.OutboxEvent, err error) {
	mm_atomic.AddUint64(&mmGetProcessingEvents.beforeGetProcessingEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProcessingEvents.afterGetProcessingEventsCounter, 1)

	mmGetProcessingEvents.t.Helper()

	if mmGetProcessingEvents.inspectFuncGetProcessingEvents != nil {
		mmGetProcessingEvents.inspectFuncGetProcessingEvents(ctx, limit, retryDelay)
	}

	mm_params := OutboxRepositoryMockGetProcessingEventsParams{ctx, limit, retryDelay}

	// Record call args
	mmGetProcessingEvents.GetProcessingEventsMock.mutex.Lock()
	mmGetProcessingEvents.GetProcessingEventsMock.callArgs = append(mmGetProcessingEvents.GetProcessingEventsMock.callArgs, &mm_params)
	mmGetProcessingEvents.GetProcessingEventsMock.mutex.Unlock()

	for _, e := range mmGetProcessingEvents.GetProcessingEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.params
		mm_want_ptrs := mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockGetProcessingEventsParams{ctx, limit, retryDelay}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetProcessingEvents.t.Errorf("OutboxRepositoryMock.GetProcessingEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetProcessingEvents.t.Errorf("OutboxRepositoryMock.GetProcessingEvents got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.retryDelay != nil && !minimock.Equal(*mm_want_ptrs.retryDelay, mm_got.retryDelay) {
				mmGetProcessingEvents.t.Errorf("OutboxRepositoryMock.GetProcessingEvents got unexpected parameter retryDelay, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.expectationOrigins.originRetryDelay, *mm_want_ptrs.retryDelay, mm_got.retryDelay, minimock.Diff(*mm_want_ptrs.retryDelay, mm_got.retryDelay))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProcessingEvents.t.Errorf("OutboxRepositoryMock.GetProcessingEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProcessingEvents.GetProcessingEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProcessingEvents.t.Fatal("No results are set for the OutboxRepositoryMock.GetProcessingEvents")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetProcessingEvents.funcGetProcessingEvents != nil {
		return mmGetProcessingEvents.funcGetProcessingEvents(ctx, limit, retryDelay)
	}
	mmGetProcessingEvents.t.Fatalf("Unexpected call to OutboxRepositoryMock.GetProcessingEvents. %v %v %v", ctx, limit, retryDelay)
	return
}

// GetProcessingEventsAfterCounter returns a count of finished OutboxRepositoryMock.GetProcessingEvents invocations
func (mmGetProcessingEvents *OutboxRepositoryMock) GetProcessingEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProcessingEvents.afterGetProcessingEventsCounter)
}

// GetProcessingEventsBeforeCounter returns a count of OutboxRepositoryMock.GetProcessingEvents invocations
func (mmGetProcessingEvents *OutboxRepositoryMock) GetProcessingEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProcessingEvents.beforeGetProcessingEventsCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.GetProcessingEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProcessingEvents *mOutboxRepositoryMockGetProcessingEvents) Calls() []*OutboxRepositoryMockGetProcessingEventsParams {
	mmGetProcessingEvents.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockGetProcessingEventsParams, len(mmGetProcessingEvents.callArgs))
	copy(argCopy, mmGetProcessingEvents.callArgs)

	mmGetProcessingEvents.mutex.RUnlock()

	return argCopy
}

// MinimockGetProcessingEventsDone returns true if the count of the GetProcessingEvents invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockGetProcessingEventsDone() bool {
	if m.GetProcessingEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetProcessingEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetProcessingEventsMock.invocationsDone()
}

// MinimockGetProcessingEventsInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockGetProcessingEventsInspect() {
	for _, e := range m.GetProcessingEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.GetProcessingEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetProcessingEventsCounter := mm_atomic.LoadUint64(&m.afterGetProcessingEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetProcessingEventsMock.defaultExpectation != nil && afterGetProcessingEventsCounter < 1 {
		if m.GetProcessingEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.GetProcessingEvents at\n%s", m.GetProcessingEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.GetProcessingEvents at\n%s with params: %#v", m.GetProcessingEventsMock.defaultExpectation.expectationOrigins.origin, *m.GetProcessingEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProcessingEvents != nil && afterGetProcessingEventsCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.GetProcessingEvents at\n%s", m.funcGetProcessingEventsOrigin)
	}

	if !m.GetProcessingEventsMock.invocationsDone() && afterGetProcessingEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.GetProcessingEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetProcessingEventsMock.expectedInvocations), m.GetProcessingEventsMock.expectedInvocationsOrigin, afterGetProcessingEventsCounter)
	}
}

type mOutboxRepositoryMockSetCompleted struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockSetCompletedExpectation
	expectations       []*OutboxRepositoryMockSetCompletedExpectation

	callArgs []*OutboxRepositoryMockSetCompletedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockSetCompletedExpectation specifies expectation struct of the OutboxRepository.SetCompleted
type OutboxRepositoryMockSetCompletedExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockSetCompletedParams
	paramPtrs          *OutboxRepositoryMockSetCompletedParamPtrs
	expectationOrigins OutboxRepositoryMockSetCompletedExpectationOrigins
	results            *OutboxRepositoryMockSetCompletedResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockSetCompletedParams contains parameters of the OutboxRepository.SetCompleted
type OutboxRepositoryMockSetCompletedParams struct {
	ctx     context.Context
	eventID uint64
	sentAt  time.Time
}

// OutboxRepositoryMockSetCompletedParamPtrs contains pointers to parameters of the OutboxRepository.SetCompleted
type OutboxRepositoryMockSetCompletedParamPtrs struct {
	ctx     *context.Context
	eventID *uint64
	sentAt  *time.Time
}

// OutboxRepositoryMockSetCompletedResults contains results of the OutboxRepository.SetCompleted
type OutboxRepositoryMockSetCompletedResults struct {
	err error
}

// OutboxRepositoryMockSetCompletedOrigins contains origins of expectations of the OutboxRepository.SetCompleted
type OutboxRepositoryMockSetCompletedExpectationOrigins struct {
	origin        string
	originCtx     string
	originEventID string
	originSentAt  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) Optional() *mOutboxRepositoryMockSetCompleted {
	mmSetCompleted.optional = true
	return mmSetCompleted
}

// Expect sets up expected params for OutboxRepository.SetCompleted
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) Expect(ctx context.Context, eventID uint64, sentAt time.Time) *mOutboxRepositoryMockSetCompleted {
	if mmSetCompleted.mock.funcSetCompleted != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Set")
	}

	if mmSetCompleted.defaultExpectation == nil {
		mmSetCompleted.defaultExpectation = &OutboxRepositoryMockSetCompletedExpectation{}
	}

	if mmSetCompleted.defaultExpectation.paramPtrs != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by ExpectParams functions")
	}

	mmSetCompleted.defaultExpectation.params = &OutboxRepositoryMockSetCompletedParams{ctx, eventID, sentAt}
	mmSetCompleted.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetCompleted.expectations {
		if minimock.Equal(e.params, mmSetCompleted.defaultExpectation.params) {
			mmSetCompleted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCompleted.defaultExpectation.params)
		}
	}

	return mmSetCompleted
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.SetCompleted
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockSetCompleted {
	if mmSetCompleted.mock.funcSetCompleted != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Set")
	}

	if mmSetCompleted.defaultExpectation == nil {
		mmSetCompleted.defaultExpectation = &OutboxRepositoryMockSetCompletedExpectation{}
	}

	if mmSetCompleted.defaultExpectation.params != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Expect")
	}

	if mmSetCompleted.defaultExpectation.paramPtrs == nil {
		mmSetCompleted.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetCompletedParamPtrs{}
	}
	mmSetCompleted.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetCompleted.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetCompleted
}

// ExpectEventIDParam2 sets up expected param eventID for OutboxRepository.SetCompleted
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) ExpectEventIDParam2(eventID uint64) *mOutboxRepositoryMockSetCompleted {
	if mmSetCompleted.mock.funcSetCompleted != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Set")
	}

	if mmSetCompleted.defaultExpectation == nil {
		mmSetCompleted.defaultExpectation = &OutboxRepositoryMockSetCompletedExpectation{}
	}

	if mmSetCompleted.defaultExpectation.params != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Expect")
	}

	if mmSetCompleted.defaultExpectation.paramPtrs == nil {
		mmSetCompleted.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetCompletedParamPtrs{}
	}
	mmSetCompleted.defaultExpectation.paramPtrs.eventID = &eventID
	mmSetCompleted.defaultExpectation.expectationOrigins.originEventID = minimock.CallerInfo(1)

	return mmSetCompleted
}

// ExpectSentAtParam3 sets up expected param sentAt for OutboxRepository.SetCompleted
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) ExpectSentAtParam3(sentAt time.Time) *mOutboxRepositoryMockSetCompleted {
	if mmSetCompleted.mock.funcSetCompleted != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Set")
	}

	if mmSetCompleted.defaultExpectation == nil {
		mmSetCompleted.defaultExpectation = &OutboxRepositoryMockSetCompletedExpectation{}
	}

	if mmSetCompleted.defaultExpectation.params != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Expect")
	}

	if mmSetCompleted.defaultExpectation.paramPtrs == nil {
		mmSetCompleted.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetCompletedParamPtrs{}
	}
	mmSetCompleted.defaultExpectation.paramPtrs.sentAt = &sentAt
	mmSetCompleted.defaultExpectation.expectationOrigins.originSentAt = minimock.CallerInfo(1)

	return mmSetCompleted
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.SetCompleted
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) Inspect(f func(ctx context.Context, eventID uint64, sentAt time.Time)) *mOutboxRepositoryMockSetCompleted {
	if mmSetCompleted.mock.inspectFuncSetCompleted != nil {
		mmSetCompleted.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.SetCompleted")
	}

	mmSetCompleted.mock.inspectFuncSetCompleted = f

	return mmSetCompleted
}

// Return sets up results that will be returned by OutboxRepository.SetCompleted
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) Return(err error) *OutboxRepositoryMock {
	if mmSetCompleted.mock.funcSetCompleted != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Set")
	}

	if mmSetCompleted.defaultExpectation == nil {
		mmSetCompleted.defaultExpectation = &OutboxRepositoryMockSetCompletedExpectation{mock: mmSetCompleted.mock}
	}
	mmSetCompleted.defaultExpectation.results = &OutboxRepositoryMockSetCompletedResults{err}
	mmSetCompleted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetCompleted.mock
}

// Set uses given function f to mock the OutboxRepository.SetCompleted method
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) Set(f func(ctx context.Context, eventID uint64, sentAt time.Time) (err error)) *OutboxRepositoryMock {
	if mmSetCompleted.defaultExpectation != nil {
		mmSetCompleted.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.SetCompleted method")
	}

	if len(mmSetCompleted.expectations) > 0 {
		mmSetCompleted.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.SetCompleted method")
	}

	mmSetCompleted.mock.funcSetCompleted = f
	mmSetCompleted.mock.funcSetCompletedOrigin = minimock.CallerInfo(1)
	return mmSetCompleted.mock
}

// When sets expectation for the OutboxRepository.SetCompleted which will trigger the result defined by the following
// Then helper
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) When(ctx context.Context, eventID uint64, sentAt time.Time) *OutboxRepositoryMockSetCompletedExpectation {
	if mmSetCompleted.mock.funcSetCompleted != nil {
		mmSetCompleted.mock.t.Fatalf("OutboxRepositoryMock.SetCompleted mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockSetCompletedExpectation{
		mock:               mmSetCompleted.mock,
		params:             &OutboxRepositoryMockSetCompletedParams{ctx, eventID, sentAt},
		expectationOrigins: OutboxRepositoryMockSetCompletedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetCompleted.expectations = append(mmSetCompleted.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.SetCompleted return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockSetCompletedExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockSetCompletedResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.SetCompleted should be invoked
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) Times(n uint64) *mOutboxRepositoryMockSetCompleted {
	if n == 0 {
		mmSetCompleted.mock.t.Fatalf("Times of OutboxRepositoryMock.SetCompleted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetCompleted.expectedInvocations, n)
	mmSetCompleted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetCompleted
}

func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) invocationsDone() bool {
	if len(mmSetCompleted.expectations) == 0 && mmSetCompleted.defaultExpectation == nil && mmSetCompleted.mock.funcSetCompleted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetCompleted.mock.afterSetCompletedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetCompleted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetCompleted implements mm_repositories.OutboxRepository
func (mmSetCompleted *OutboxRepositoryMock) SetCompleted(ctx context.Context, eventID uint64, sentAt time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetCompleted.beforeSetCompletedCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCompleted.afterSetCompletedCounter, 1)

	mmSetCompleted.t.Helper()

	if mmSetCompleted.inspectFuncSetCompleted != nil {
		mmSetCompleted.inspectFuncSetCompleted(ctx, eventID, sentAt)
	}

	mm_params := OutboxRepositoryMockSetCompletedParams{ctx, eventID, sentAt}

	// Record call args
	mmSetCompleted.SetCompletedMock.mutex.Lock()
	mmSetCompleted.SetCompletedMock.callArgs = append(mmSetCompleted.SetCompletedMock.callArgs, &mm_params)
	mmSetCompleted.SetCompletedMock.mutex.Unlock()

	for _, e := range mmSetCompleted.SetCompletedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetCompleted.SetCompletedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCompleted.SetCompletedMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCompleted.SetCompletedMock.defaultExpectation.params
		mm_want_ptrs := mmSetCompleted.SetCompletedMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockSetCompletedParams{ctx, eventID, sentAt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetCompleted.t.Errorf("OutboxRepositoryMock.SetCompleted got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCompleted.SetCompletedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.eventID != nil && !minimock.Equal(*mm_want_ptrs.eventID, mm_got.eventID) {
				mmSetCompleted.t.Errorf("OutboxRepositoryMock.SetCompleted got unexpected parameter eventID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCompleted.SetCompletedMock.defaultExpectation.expectationOrigins.originEventID, *mm_want_ptrs.eventID, mm_got.eventID, minimock.Diff(*mm_want_ptrs.eventID, mm_got.eventID))
			}

			if mm_want_ptrs.sentAt != nil && !minimock.Equal(*mm_want_ptrs.sentAt, mm_got.sentAt) {
				mmSetCompleted.t.Errorf("OutboxRepositoryMock.SetCompleted got unexpected parameter sentAt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCompleted.SetCompletedMock.defaultExpectation.expectationOrigins.originSentAt, *mm_want_ptrs.sentAt, mm_got.sentAt, minimock.Diff(*mm_want_ptrs.sentAt, mm_got.sentAt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCompleted.t.Errorf("OutboxRepositoryMock.SetCompleted got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetCompleted.SetCompletedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetCompleted.SetCompletedMock.defaultExpectation.results
		if mm_results == nil {
			mmSetCompleted.t.Fatal("No results are set for the OutboxRepositoryMock.SetCompleted")
		}
		return (*mm_results).err
	}
	if mmSetCompleted.funcSetCompleted != nil {
		return mmSetCompleted.funcSetCompleted(ctx, eventID, sentAt)
	}
	mmSetCompleted.t.Fatalf("Unexpected call to OutboxRepositoryMock.SetCompleted. %v %v %v", ctx, eventID, sentAt)
	return
}

// SetCompletedAfterCounter returns a count of finished OutboxRepositoryMock.SetCompleted invocations
func (mmSetCompleted *OutboxRepositoryMock) SetCompletedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCompleted.afterSetCompletedCounter)
}

// SetCompletedBeforeCounter returns a count of OutboxRepositoryMock.SetCompleted invocations
func (mmSetCompleted *OutboxRepositoryMock) SetCompletedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCompleted.beforeSetCompletedCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.SetCompleted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCompleted *mOutboxRepositoryMockSetCompleted) Calls() []*OutboxRepositoryMockSetCompletedParams {
	mmSetCompleted.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockSetCompletedParams, len(mmSetCompleted.callArgs))
	copy(argCopy, mmSetCompleted.callArgs)

	mmSetCompleted.mutex.RUnlock()

	return argCopy
}

// MinimockSetCompletedDone returns true if the count of the SetCompleted invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockSetCompletedDone() bool {
	if m.SetCompletedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetCompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetCompletedMock.invocationsDone()
}

// MinimockSetCompletedInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockSetCompletedInspect() {
	for _, e := range m.SetCompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetCompleted at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCompletedCounter := mm_atomic.LoadUint64(&m.afterSetCompletedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetCompletedMock.defaultExpectation != nil && afterSetCompletedCounter < 1 {
		if m.SetCompletedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetCompleted at\n%s", m.SetCompletedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetCompleted at\n%s with params: %#v", m.SetCompletedMock.defaultExpectation.expectationOrigins.origin, *m.SetCompletedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCompleted != nil && afterSetCompletedCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.SetCompleted at\n%s", m.funcSetCompletedOrigin)
	}

	if !m.SetCompletedMock.invocationsDone() && afterSetCompletedCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.SetCompleted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetCompletedMock.expectedInvocations), m.SetCompletedMock.expectedInvocationsOrigin, afterSetCompletedCounter)
	}
}

type mOutboxRepositoryMockSetFailed struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockSetFailedExpectation
	expectations       []*OutboxRepositoryMockSetFailedExpectation

	callArgs []*OutboxRepositoryMockSetFailedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockSetFailedExpectation specifies expectation struct of the OutboxRepository.SetFailed
type OutboxRepositoryMockSetFailedExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockSetFailedParams
	paramPtrs          *OutboxRepositoryMockSetFailedParamPtrs
	expectationOrigins OutboxRepositoryMockSetFailedExpectationOrigins
	results            *OutboxRepositoryMockSetFailedResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockSetFailedParams contains parameters of the OutboxRepository.SetFailed
type OutboxRepositoryMockSetFailedParams struct {
	ctx     context.Context
	eventID uint64
	errMsg  string
}

// OutboxRepositoryMockSetFailedParamPtrs contains pointers to parameters of the OutboxRepository.SetFailed
type OutboxRepositoryMockSetFailedParamPtrs struct {
	ctx     *context.Context
	eventID *uint64
	errMsg  *string
}

// OutboxRepositoryMockSetFailedResults contains results of the OutboxRepository.SetFailed
type OutboxRepositoryMockSetFailedResults struct {
	err error
}

// OutboxRepositoryMockSetFailedOrigins contains origins of expectations of the OutboxRepository.SetFailed
type OutboxRepositoryMockSetFailedExpectationOrigins struct {
	origin        string
	originCtx     string
	originEventID string
	originErrMsg  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetFailed *mOutboxRepositoryMockSetFailed) Optional() *mOutboxRepositoryMockSetFailed {
	mmSetFailed.optional = true
	return mmSetFailed
}

// Expect sets up expected params for OutboxRepository.SetFailed
func (mmSetFailed *mOutboxRepositoryMockSetFailed) Expect(ctx context.Context, eventID uint64, errMsg string) *mOutboxRepositoryMockSetFailed {
	if mmSetFailed.mock.funcSetFailed != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Set")
	}

	if mmSetFailed.defaultExpectation == nil {
		mmSetFailed.defaultExpectation = &OutboxRepositoryMockSetFailedExpectation{}
	}

	if mmSetFailed.defaultExpectation.paramPtrs != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by ExpectParams functions")
	}

	mmSetFailed.defaultExpectation.params = &OutboxRepositoryMockSetFailedParams{ctx, eventID, errMsg}
	mmSetFailed.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetFailed.expectations {
		if minimock.Equal(e.params, mmSetFailed.defaultExpectation.params) {
			mmSetFailed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetFailed.defaultExpectation.params)
		}
	}

	return mmSetFailed
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.SetFailed
func (mmSetFailed *mOutboxRepositoryMockSetFailed) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockSetFailed {
	if mmSetFailed.mock.funcSetFailed != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Set")
	}

	if mmSetFailed.defaultExpectation == nil {
		mmSetFailed.defaultExpectation = &OutboxRepositoryMockSetFailedExpectation{}
	}

	if mmSetFailed.defaultExpectation.params != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Expect")
	}

	if mmSetFailed.defaultExpectation.paramPtrs == nil {
		mmSetFailed.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetFailedParamPtrs{}
	}
	mmSetFailed.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetFailed.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetFailed
}

// ExpectEventIDParam2 sets up expected param eventID for OutboxRepository.SetFailed
func (mmSetFailed *mOutboxRepositoryMockSetFailed) ExpectEventIDParam2(eventID uint64) *mOutboxRepositoryMockSetFailed {
	if mmSetFailed.mock.funcSetFailed != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Set")
	}

	if mmSetFailed.defaultExpectation == nil {
		mmSetFailed.defaultExpectation = &OutboxRepositoryMockSetFailedExpectation{}
	}

	if mmSetFailed.defaultExpectation.params != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Expect")
	}

	if mmSetFailed.defaultExpectation.paramPtrs == nil {
		mmSetFailed.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetFailedParamPtrs{}
	}
	mmSetFailed.defaultExpectation.paramPtrs.eventID = &eventID
	mmSetFailed.defaultExpectation.expectationOrigins.originEventID = minimock.CallerInfo(1)

	return mmSetFailed
}

// ExpectErrMsgParam3 sets up expected param errMsg for OutboxRepository.SetFailed
func (mmSetFailed *mOutboxRepositoryMockSetFailed) ExpectErrMsgParam3(errMsg string) *mOutboxRepositoryMockSetFailed {
	if mmSetFailed.mock.funcSetFailed != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Set")
	}

	if mmSetFailed.defaultExpectation == nil {
		mmSetFailed.defaultExpectation = &OutboxRepositoryMockSetFailedExpectation{}
	}

	if mmSetFailed.defaultExpectation.params != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Expect")
	}

	if mmSetFailed.defaultExpectation.paramPtrs == nil {
		mmSetFailed.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetFailedParamPtrs{}
	}
	mmSetFailed.defaultExpectation.paramPtrs.errMsg = &errMsg
	mmSetFailed.defaultExpectation.expectationOrigins.originErrMsg = minimock.CallerInfo(1)

	return mmSetFailed
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.SetFailed
func (mmSetFailed *mOutboxRepositoryMockSetFailed) Inspect(f func(ctx context.Context, eventID uint64, errMsg string)) *mOutboxRepositoryMockSetFailed {
	if mmSetFailed.mock.inspectFuncSetFailed != nil {
		mmSetFailed.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.SetFailed")
	}

	mmSetFailed.mock.inspectFuncSetFailed = f

	return mmSetFailed
}

// Return sets up results that will be returned by OutboxRepository.SetFailed
func (mmSetFailed *mOutboxRepositoryMockSetFailed) Return(err error) *OutboxRepositoryMock {
	if mmSetFailed.mock.funcSetFailed != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Set")
	}

	if mmSetFailed.defaultExpectation == nil {
		mmSetFailed.defaultExpectation = &OutboxRepositoryMockSetFailedExpectation{mock: mmSetFailed.mock}
	}
	mmSetFailed.defaultExpectation.results = &OutboxRepositoryMockSetFailedResults{err}
	mmSetFailed.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetFailed.mock
}

// Set uses given function f to mock the OutboxRepository.SetFailed method
func (mmSetFailed *mOutboxRepositoryMockSetFailed) Set(f func(ctx context.Context, eventID uint64, errMsg string) (err error)) *OutboxRepositoryMock {
	if mmSetFailed.defaultExpectation != nil {
		mmSetFailed.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.SetFailed method")
	}

	if len(mmSetFailed.expectations) > 0 {
		mmSetFailed.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.SetFailed method")
	}

	mmSetFailed.mock.funcSetFailed = f
	mmSetFailed.mock.funcSetFailedOrigin = minimock.CallerInfo(1)
	return mmSetFailed.mock
}

// When sets expectation for the OutboxRepository.SetFailed which will trigger the result defined by the following
// Then helper
func (mmSetFailed *mOutboxRepositoryMockSetFailed) When(ctx context.Context, eventID uint64, errMsg string) *OutboxRepositoryMockSetFailedExpectation {
	if mmSetFailed.mock.funcSetFailed != nil {
		mmSetFailed.mock.t.Fatalf("OutboxRepositoryMock.SetFailed mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockSetFailedExpectation{
		mock:               mmSetFailed.mock,
		params:             &OutboxRepositoryMockSetFailedParams{ctx, eventID, errMsg},
		expectationOrigins: OutboxRepositoryMockSetFailedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetFailed.expectations = append(mmSetFailed.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.SetFailed return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockSetFailedExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockSetFailedResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.SetFailed should be invoked
func (mmSetFailed *mOutboxRepositoryMockSetFailed) Times(n uint64) *mOutboxRepositoryMockSetFailed {
	if n == 0 {
		mmSetFailed.mock.t.Fatalf("Times of OutboxRepositoryMock.SetFailed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetFailed.expectedInvocations, n)
	mmSetFailed.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetFailed
}

func (mmSetFailed *mOutboxRepositoryMockSetFailed) invocationsDone() bool {
	if len(mmSetFailed.expectations) == 0 && mmSetFailed.defaultExpectation == nil && mmSetFailed.mock.funcSetFailed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetFailed.mock.afterSetFailedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetFailed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetFailed implements mm_repositories.OutboxRepository
func (mmSetFailed *OutboxRepositoryMock) SetFailed(ctx context.Context, eventID uint64, errMsg string) (err error) {
	mm_atomic.AddUint64(&mmSetFailed.beforeSetFailedCounter, 1)
	defer mm_atomic.AddUint64(&mmSetFailed.afterSetFailedCounter, 1)

	mmSetFailed.t.Helper()

	if mmSetFailed.inspectFuncSetFailed != nil {
		mmSetFailed.inspectFuncSetFailed(ctx, eventID, errMsg)
	}

	mm_params := OutboxRepositoryMockSetFailedParams{ctx, eventID, errMsg}

	// Record call args
	mmSetFailed.SetFailedMock.mutex.Lock()
	mmSetFailed.SetFailedMock.callArgs = append(mmSetFailed.SetFailedMock.callArgs, &mm_params)
	mmSetFailed.SetFailedMock.mutex.Unlock()

	for _, e := range mmSetFailed.SetFailedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetFailed.SetFailedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetFailed.SetFailedMock.defaultExpectation.Counter, 1)
		mm_want := mmSetFailed.SetFailedMock.defaultExpectation.params
		mm_want_ptrs := mmSetFailed.SetFailedMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockSetFailedParams{ctx, eventID, errMsg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetFailed.t.Errorf("OutboxRepositoryMock.SetFailed got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetFailed.SetFailedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.eventID != nil && !minimock.Equal(*mm_want_ptrs.eventID, mm_got.eventID) {
				mmSetFailed.t.Errorf("OutboxRepositoryMock.SetFailed got unexpected parameter eventID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetFailed.SetFailedMock.defaultExpectation.expectationOrigins.originEventID, *mm_want_ptrs.eventID, mm_got.eventID, minimock.Diff(*mm_want_ptrs.eventID, mm_got.eventID))
			}

			if mm_want_ptrs.errMsg != nil && !minimock.Equal(*mm_want_ptrs.errMsg, mm_got.errMsg) {
				mmSetFailed.t.Errorf("OutboxRepositoryMock.SetFailed got unexpected parameter errMsg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetFailed.SetFailedMock.defaultExpectation.expectationOrigins.originErrMsg, *mm_want_ptrs.errMsg, mm_got.errMsg, minimock.Diff(*mm_want_ptrs.errMsg, mm_got.errMsg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetFailed.t.Errorf("OutboxRepositoryMock.SetFailed got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetFailed.SetFailedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetFailed.SetFailedMock.defaultExpectation.results
		if mm_results == nil {
			mmSetFailed.t.Fatal("No results are set for the OutboxRepositoryMock.SetFailed")
		}
		return (*mm_results).err
	}
	if mmSetFailed.funcSetFailed != nil {
		return mmSetFailed.funcSetFailed(ctx, eventID, errMsg)
	}
	mmSetFailed.t.Fatalf("Unexpected call to OutboxRepositoryMock.SetFailed. %v %v %v", ctx, eventID, errMsg)
	return
}

// SetFailedAfterCounter returns a count of finished OutboxRepositoryMock.SetFailed invocations
func (mmSetFailed *OutboxRepositoryMock) SetFailedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFailed.afterSetFailedCounter)
}

// SetFailedBeforeCounter returns a count of OutboxRepositoryMock.SetFailed invocations
func (mmSetFailed *OutboxRepositoryMock) SetFailedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetFailed.beforeSetFailedCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.SetFailed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetFailed *mOutboxRepositoryMockSetFailed) Calls() []*OutboxRepositoryMockSetFailedParams {
	mmSetFailed.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockSetFailedParams, len(mmSetFailed.callArgs))
	copy(argCopy, mmSetFailed.callArgs)

	mmSetFailed.mutex.RUnlock()

	return argCopy
}

// MinimockSetFailedDone returns true if the count of the SetFailed invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockSetFailedDone() bool {
	if m.SetFailedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetFailedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetFailedMock.invocationsDone()
}

// MinimockSetFailedInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockSetFailedInspect() {
	for _, e := range m.SetFailedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetFailed at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetFailedCounter := mm_atomic.LoadUint64(&m.afterSetFailedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetFailedMock.defaultExpectation != nil && afterSetFailedCounter < 1 {
		if m.SetFailedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetFailed at\n%s", m.SetFailedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetFailed at\n%s with params: %#v", m.SetFailedMock.defaultExpectation.expectationOrigins.origin, *m.SetFailedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetFailed != nil && afterSetFailedCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.SetFailed at\n%s", m.funcSetFailedOrigin)
	}

	if !m.SetFailedMock.invocationsDone() && afterSetFailedCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.SetFailed at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetFailedMock.expectedInvocations), m.SetFailedMock.expectedInvocationsOrigin, afterSetFailedCounter)
	}
}

type mOutboxRepositoryMockSetProcessing struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockSetProcessingExpectation
	expectations       []*OutboxRepositoryMockSetProcessingExpectation

	callArgs []*OutboxRepositoryMockSetProcessingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockSetProcessingExpectation specifies expectation struct of the OutboxRepository.SetProcessing
type OutboxRepositoryMockSetProcessingExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockSetProcessingParams
	paramPtrs          *OutboxRepositoryMockSetProcessingParamPtrs
	expectationOrigins OutboxRepositoryMockSetProcessingExpectationOrigins
	results            *OutboxRepositoryMockSetProcessingResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockSetProcessingParams contains parameters of the OutboxRepository.SetProcessing
type OutboxRepositoryMockSetProcessingParams struct {
	ctx        context.Context
	limit      int
	retryDelay time.Duration
}

// OutboxRepositoryMockSetProcessingParamPtrs contains pointers to parameters of the OutboxRepository.SetProcessing
type OutboxRepositoryMockSetProcessingParamPtrs struct {
	ctx        *context.Context
	limit      *int
	retryDelay *time.Duration
}

// OutboxRepositoryMockSetProcessingResults contains results of the OutboxRepository.SetProcessing
type OutboxRepositoryMockSetProcessingResults struct {
	err error
}

// OutboxRepositoryMockSetProcessingOrigins contains origins of expectations of the OutboxRepository.SetProcessing
type OutboxRepositoryMockSetProcessingExpectationOrigins struct {
	origin           string
	originCtx        string
	originLimit      string
	originRetryDelay string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) Optional() *mOutboxRepositoryMockSetProcessing {
	mmSetProcessing.optional = true
	return mmSetProcessing
}

// Expect sets up expected params for OutboxRepository.SetProcessing
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) Expect(ctx context.Context, limit int, retryDelay time.Duration) *mOutboxRepositoryMockSetProcessing {
	if mmSetProcessing.mock.funcSetProcessing != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Set")
	}

	if mmSetProcessing.defaultExpectation == nil {
		mmSetProcessing.defaultExpectation = &OutboxRepositoryMockSetProcessingExpectation{}
	}

	if mmSetProcessing.defaultExpectation.paramPtrs != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by ExpectParams functions")
	}

	mmSetProcessing.defaultExpectation.params = &OutboxRepositoryMockSetProcessingParams{ctx, limit, retryDelay}
	mmSetProcessing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetProcessing.expectations {
		if minimock.Equal(e.params, mmSetProcessing.defaultExpectation.params) {
			mmSetProcessing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetProcessing.defaultExpectation.params)
		}
	}

	return mmSetProcessing
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.SetProcessing
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockSetProcessing {
	if mmSetProcessing.mock.funcSetProcessing != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Set")
	}

	if mmSetProcessing.defaultExpectation == nil {
		mmSetProcessing.defaultExpectation = &OutboxRepositoryMockSetProcessingExpectation{}
	}

	if mmSetProcessing.defaultExpectation.params != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Expect")
	}

	if mmSetProcessing.defaultExpectation.paramPtrs == nil {
		mmSetProcessing.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetProcessingParamPtrs{}
	}
	mmSetProcessing.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetProcessing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetProcessing
}

// ExpectLimitParam2 sets up expected param limit for OutboxRepository.SetProcessing
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) ExpectLimitParam2(limit int) *mOutboxRepositoryMockSetProcessing {
	if mmSetProcessing.mock.funcSetProcessing != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Set")
	}

	if mmSetProcessing.defaultExpectation == nil {
		mmSetProcessing.defaultExpectation = &OutboxRepositoryMockSetProcessingExpectation{}
	}

	if mmSetProcessing.defaultExpectation.params != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Expect")
	}

	if mmSetProcessing.defaultExpectation.paramPtrs == nil {
		mmSetProcessing.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetProcessingParamPtrs{}
	}
	mmSetProcessing.defaultExpectation.paramPtrs.limit = &limit
	mmSetProcessing.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmSetProcessing
}

// ExpectRetryDelayParam3 sets up expected param retryDelay for OutboxRepository.SetProcessing
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) ExpectRetryDelayParam3(retryDelay time.Duration) *mOutboxRepositoryMockSetProcessing {
	if mmSetProcessing.mock.funcSetProcessing != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Set")
	}

	if mmSetProcessing.defaultExpectation == nil {
		mmSetProcessing.defaultExpectation = &OutboxRepositoryMockSetProcessingExpectation{}
	}

	if mmSetProcessing.defaultExpectation.params != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Expect")
	}

	if mmSetProcessing.defaultExpectation.paramPtrs == nil {
		mmSetProcessing.defaultExpectation.paramPtrs = &OutboxRepositoryMockSetProcessingParamPtrs{}
	}
	mmSetProcessing.defaultExpectation.paramPtrs.retryDelay = &retryDelay
	mmSetProcessing.defaultExpectation.expectationOrigins.originRetryDelay = minimock.CallerInfo(1)

	return mmSetProcessing
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.SetProcessing
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) Inspect(f func(ctx context.Context, limit int, retryDelay time.Duration)) *mOutboxRepositoryMockSetProcessing {
	if mmSetProcessing.mock.inspectFuncSetProcessing != nil {
		mmSetProcessing.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.SetProcessing")
	}

	mmSetProcessing.mock.inspectFuncSetProcessing = f

	return mmSetProcessing
}

// Return sets up results that will be returned by OutboxRepository.SetProcessing
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) Return(err error) *OutboxRepositoryMock {
	if mmSetProcessing.mock.funcSetProcessing != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Set")
	}

	if mmSetProcessing.defaultExpectation == nil {
		mmSetProcessing.defaultExpectation = &OutboxRepositoryMockSetProcessingExpectation{mock: mmSetProcessing.mock}
	}
	mmSetProcessing.defaultExpectation.results = &OutboxRepositoryMockSetProcessingResults{err}
	mmSetProcessing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetProcessing.mock
}

// Set uses given function f to mock the OutboxRepository.SetProcessing method
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) Set(f func(ctx context.Context, limit int, retryDelay time.Duration) (err error)) *OutboxRepositoryMock {
	if mmSetProcessing.defaultExpectation != nil {
		mmSetProcessing.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.SetProcessing method")
	}

	if len(mmSetProcessing.expectations) > 0 {
		mmSetProcessing.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.SetProcessing method")
	}

	mmSetProcessing.mock.funcSetProcessing = f
	mmSetProcessing.mock.funcSetProcessingOrigin = minimock.CallerInfo(1)
	return mmSetProcessing.mock
}

// When sets expectation for the OutboxRepository.SetProcessing which will trigger the result defined by the following
// Then helper
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) When(ctx context.Context, limit int, retryDelay time.Duration) *OutboxRepositoryMockSetProcessingExpectation {
	if mmSetProcessing.mock.funcSetProcessing != nil {
		mmSetProcessing.mock.t.Fatalf("OutboxRepositoryMock.SetProcessing mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockSetProcessingExpectation{
		mock:               mmSetProcessing.mock,
		params:             &OutboxRepositoryMockSetProcessingParams{ctx, limit, retryDelay},
		expectationOrigins: OutboxRepositoryMockSetProcessingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetProcessing.expectations = append(mmSetProcessing.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.SetProcessing return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockSetProcessingExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockSetProcessingResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.SetProcessing should be invoked
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) Times(n uint64) *mOutboxRepositoryMockSetProcessing {
	if n == 0 {
		mmSetProcessing.mock.t.Fatalf("Times of OutboxRepositoryMock.SetProcessing mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetProcessing.expectedInvocations, n)
	mmSetProcessing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetProcessing
}

func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) invocationsDone() bool {
	if len(mmSetProcessing.expectations) == 0 && mmSetProcessing.defaultExpectation == nil && mmSetProcessing.mock.funcSetProcessing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetProcessing.mock.afterSetProcessingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetProcessing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetProcessing implements mm_repositories.OutboxRepository
func (mmSetProcessing *OutboxRepositoryMock) SetProcessing(ctx context.Context, limit int, retryDelay time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSetProcessing.beforeSetProcessingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetProcessing.afterSetProcessingCounter, 1)

	mmSetProcessing.t.Helper()

	if mmSetProcessing.inspectFuncSetProcessing != nil {
		mmSetProcessing.inspectFuncSetProcessing(ctx, limit, retryDelay)
	}

	mm_params := OutboxRepositoryMockSetProcessingParams{ctx, limit, retryDelay}

	// Record call args
	mmSetProcessing.SetProcessingMock.mutex.Lock()
	mmSetProcessing.SetProcessingMock.callArgs = append(mmSetProcessing.SetProcessingMock.callArgs, &mm_params)
	mmSetProcessing.SetProcessingMock.mutex.Unlock()

	for _, e := range mmSetProcessing.SetProcessingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetProcessing.SetProcessingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetProcessing.SetProcessingMock.defaultExpectation.Counter, 1)
		mm_want := mmSetProcessing.SetProcessingMock.defaultExpectation.params
		mm_want_ptrs := mmSetProcessing.SetProcessingMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockSetProcessingParams{ctx, limit, retryDelay}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetProcessing.t.Errorf("OutboxRepositoryMock.SetProcessing got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetProcessing.SetProcessingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmSetProcessing.t.Errorf("OutboxRepositoryMock.SetProcessing got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetProcessing.SetProcessingMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.retryDelay != nil && !minimock.Equal(*mm_want_ptrs.retryDelay, mm_got.retryDelay) {
				mmSetProcessing.t.Errorf("OutboxRepositoryMock.SetProcessing got unexpected parameter retryDelay, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetProcessing.SetProcessingMock.defaultExpectation.expectationOrigins.originRetryDelay, *mm_want_ptrs.retryDelay, mm_got.retryDelay, minimock.Diff(*mm_want_ptrs.retryDelay, mm_got.retryDelay))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetProcessing.t.Errorf("OutboxRepositoryMock.SetProcessing got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetProcessing.SetProcessingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetProcessing.SetProcessingMock.defaultExpectation.results
		if mm_results == nil {
			mmSetProcessing.t.Fatal("No results are set for the OutboxRepositoryMock.SetProcessing")
		}
		return (*mm_results).err
	}
	if mmSetProcessing.funcSetProcessing != nil {
		return mmSetProcessing.funcSetProcessing(ctx, limit, retryDelay)
	}
	mmSetProcessing.t.Fatalf("Unexpected call to OutboxRepositoryMock.SetProcessing. %v %v %v", ctx, limit, retryDelay)
	return
}

// SetProcessingAfterCounter returns a count of finished OutboxRepositoryMock.SetProcessing invocations
func (mmSetProcessing *OutboxRepositoryMock) SetProcessingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetProcessing.afterSetProcessingCounter)
}

// SetProcessingBeforeCounter returns a count of OutboxRepositoryMock.SetProcessing invocations
func (mmSetProcessing *OutboxRepositoryMock) SetProcessingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetProcessing.beforeSetProcessingCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.SetProcessing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetProcessing *mOutboxRepositoryMockSetProcessing) Calls() []*OutboxRepositoryMockSetProcessingParams {
	mmSetProcessing.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockSetProcessingParams, len(mmSetProcessing.callArgs))
	copy(argCopy, mmSetProcessing.callArgs)

	mmSetProcessing.mutex.RUnlock()

	return argCopy
}

// MinimockSetProcessingDone returns true if the count of the SetProcessing invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockSetProcessingDone() bool {
	if m.SetProcessingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetProcessingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetProcessingMock.invocationsDone()
}

// MinimockSetProcessingInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockSetProcessingInspect() {
	for _, e := range m.SetProcessingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetProcessing at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetProcessingCounter := mm_atomic.LoadUint64(&m.afterSetProcessingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetProcessingMock.defaultExpectation != nil && afterSetProcessingCounter < 1 {
		if m.SetProcessingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetProcessing at\n%s", m.SetProcessingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.SetProcessing at\n%s with params: %#v", m.SetProcessingMock.defaultExpectation.expectationOrigins.origin, *m.SetProcessingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetProcessing != nil && afterSetProcessingCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.SetProcessing at\n%s", m.funcSetProcessingOrigin)
	}

	if !m.SetProcessingMock.invocationsDone() && afterSetProcessingCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.SetProcessing at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetProcessingMock.expectedInvocations), m.SetProcessingMock.expectedInvocationsOrigin, afterSetProcessingCounter)
	}
}

type mOutboxRepositoryMockUpdateError struct {
	optional           bool
	mock               *OutboxRepositoryMock
	defaultExpectation *OutboxRepositoryMockUpdateErrorExpectation
	expectations       []*OutboxRepositoryMockUpdateErrorExpectation

	callArgs []*OutboxRepositoryMockUpdateErrorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OutboxRepositoryMockUpdateErrorExpectation specifies expectation struct of the OutboxRepository.UpdateError
type OutboxRepositoryMockUpdateErrorExpectation struct {
	mock               *OutboxRepositoryMock
	params             *OutboxRepositoryMockUpdateErrorParams
	paramPtrs          *OutboxRepositoryMockUpdateErrorParamPtrs
	expectationOrigins OutboxRepositoryMockUpdateErrorExpectationOrigins
	results            *OutboxRepositoryMockUpdateErrorResults
	returnOrigin       string
	Counter            uint64
}

// OutboxRepositoryMockUpdateErrorParams contains parameters of the OutboxRepository.UpdateError
type OutboxRepositoryMockUpdateErrorParams struct {
	ctx     context.Context
	eventID uint64
	errMsg  string
}

// OutboxRepositoryMockUpdateErrorParamPtrs contains pointers to parameters of the OutboxRepository.UpdateError
type OutboxRepositoryMockUpdateErrorParamPtrs struct {
	ctx     *context.Context
	eventID *uint64
	errMsg  *string
}

// OutboxRepositoryMockUpdateErrorResults contains results of the OutboxRepository.UpdateError
type OutboxRepositoryMockUpdateErrorResults struct {
	err error
}

// OutboxRepositoryMockUpdateErrorOrigins contains origins of expectations of the OutboxRepository.UpdateError
type OutboxRepositoryMockUpdateErrorExpectationOrigins struct {
	origin        string
	originCtx     string
	originEventID string
	originErrMsg  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateError *mOutboxRepositoryMockUpdateError) Optional() *mOutboxRepositoryMockUpdateError {
	mmUpdateError.optional = true
	return mmUpdateError
}

// Expect sets up expected params for OutboxRepository.UpdateError
func (mmUpdateError *mOutboxRepositoryMockUpdateError) Expect(ctx context.Context, eventID uint64, errMsg string) *mOutboxRepositoryMockUpdateError {
	if mmUpdateError.mock.funcUpdateError != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Set")
	}

	if mmUpdateError.defaultExpectation == nil {
		mmUpdateError.defaultExpectation = &OutboxRepositoryMockUpdateErrorExpectation{}
	}

	if mmUpdateError.defaultExpectation.paramPtrs != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by ExpectParams functions")
	}

	mmUpdateError.defaultExpectation.params = &OutboxRepositoryMockUpdateErrorParams{ctx, eventID, errMsg}
	mmUpdateError.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateError.expectations {
		if minimock.Equal(e.params, mmUpdateError.defaultExpectation.params) {
			mmUpdateError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateError.defaultExpectation.params)
		}
	}

	return mmUpdateError
}

// ExpectCtxParam1 sets up expected param ctx for OutboxRepository.UpdateError
func (mmUpdateError *mOutboxRepositoryMockUpdateError) ExpectCtxParam1(ctx context.Context) *mOutboxRepositoryMockUpdateError {
	if mmUpdateError.mock.funcUpdateError != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Set")
	}

	if mmUpdateError.defaultExpectation == nil {
		mmUpdateError.defaultExpectation = &OutboxRepositoryMockUpdateErrorExpectation{}
	}

	if mmUpdateError.defaultExpectation.params != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Expect")
	}

	if mmUpdateError.defaultExpectation.paramPtrs == nil {
		mmUpdateError.defaultExpectation.paramPtrs = &OutboxRepositoryMockUpdateErrorParamPtrs{}
	}
	mmUpdateError.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateError.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateError
}

// ExpectEventIDParam2 sets up expected param eventID for OutboxRepository.UpdateError
func (mmUpdateError *mOutboxRepositoryMockUpdateError) ExpectEventIDParam2(eventID uint64) *mOutboxRepositoryMockUpdateError {
	if mmUpdateError.mock.funcUpdateError != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Set")
	}

	if mmUpdateError.defaultExpectation == nil {
		mmUpdateError.defaultExpectation = &OutboxRepositoryMockUpdateErrorExpectation{}
	}

	if mmUpdateError.defaultExpectation.params != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Expect")
	}

	if mmUpdateError.defaultExpectation.paramPtrs == nil {
		mmUpdateError.defaultExpectation.paramPtrs = &OutboxRepositoryMockUpdateErrorParamPtrs{}
	}
	mmUpdateError.defaultExpectation.paramPtrs.eventID = &eventID
	mmUpdateError.defaultExpectation.expectationOrigins.originEventID = minimock.CallerInfo(1)

	return mmUpdateError
}

// ExpectErrMsgParam3 sets up expected param errMsg for OutboxRepository.UpdateError
func (mmUpdateError *mOutboxRepositoryMockUpdateError) ExpectErrMsgParam3(errMsg string) *mOutboxRepositoryMockUpdateError {
	if mmUpdateError.mock.funcUpdateError != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Set")
	}

	if mmUpdateError.defaultExpectation == nil {
		mmUpdateError.defaultExpectation = &OutboxRepositoryMockUpdateErrorExpectation{}
	}

	if mmUpdateError.defaultExpectation.params != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Expect")
	}

	if mmUpdateError.defaultExpectation.paramPtrs == nil {
		mmUpdateError.defaultExpectation.paramPtrs = &OutboxRepositoryMockUpdateErrorParamPtrs{}
	}
	mmUpdateError.defaultExpectation.paramPtrs.errMsg = &errMsg
	mmUpdateError.defaultExpectation.expectationOrigins.originErrMsg = minimock.CallerInfo(1)

	return mmUpdateError
}

// Inspect accepts an inspector function that has same arguments as the OutboxRepository.UpdateError
func (mmUpdateError *mOutboxRepositoryMockUpdateError) Inspect(f func(ctx context.Context, eventID uint64, errMsg string)) *mOutboxRepositoryMockUpdateError {
	if mmUpdateError.mock.inspectFuncUpdateError != nil {
		mmUpdateError.mock.t.Fatalf("Inspect function is already set for OutboxRepositoryMock.UpdateError")
	}

	mmUpdateError.mock.inspectFuncUpdateError = f

	return mmUpdateError
}

// Return sets up results that will be returned by OutboxRepository.UpdateError
func (mmUpdateError *mOutboxRepositoryMockUpdateError) Return(err error) *OutboxRepositoryMock {
	if mmUpdateError.mock.funcUpdateError != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Set")
	}

	if mmUpdateError.defaultExpectation == nil {
		mmUpdateError.defaultExpectation = &OutboxRepositoryMockUpdateErrorExpectation{mock: mmUpdateError.mock}
	}
	mmUpdateError.defaultExpectation.results = &OutboxRepositoryMockUpdateErrorResults{err}
	mmUpdateError.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateError.mock
}

// Set uses given function f to mock the OutboxRepository.UpdateError method
func (mmUpdateError *mOutboxRepositoryMockUpdateError) Set(f func(ctx context.Context, eventID uint64, errMsg string) (err error)) *OutboxRepositoryMock {
	if mmUpdateError.defaultExpectation != nil {
		mmUpdateError.mock.t.Fatalf("Default expectation is already set for the OutboxRepository.UpdateError method")
	}

	if len(mmUpdateError.expectations) > 0 {
		mmUpdateError.mock.t.Fatalf("Some expectations are already set for the OutboxRepository.UpdateError method")
	}

	mmUpdateError.mock.funcUpdateError = f
	mmUpdateError.mock.funcUpdateErrorOrigin = minimock.CallerInfo(1)
	return mmUpdateError.mock
}

// When sets expectation for the OutboxRepository.UpdateError which will trigger the result defined by the following
// Then helper
func (mmUpdateError *mOutboxRepositoryMockUpdateError) When(ctx context.Context, eventID uint64, errMsg string) *OutboxRepositoryMockUpdateErrorExpectation {
	if mmUpdateError.mock.funcUpdateError != nil {
		mmUpdateError.mock.t.Fatalf("OutboxRepositoryMock.UpdateError mock is already set by Set")
	}

	expectation := &OutboxRepositoryMockUpdateErrorExpectation{
		mock:               mmUpdateError.mock,
		params:             &OutboxRepositoryMockUpdateErrorParams{ctx, eventID, errMsg},
		expectationOrigins: OutboxRepositoryMockUpdateErrorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateError.expectations = append(mmUpdateError.expectations, expectation)
	return expectation
}

// Then sets up OutboxRepository.UpdateError return parameters for the expectation previously defined by the When method
func (e *OutboxRepositoryMockUpdateErrorExpectation) Then(err error) *OutboxRepositoryMock {
	e.results = &OutboxRepositoryMockUpdateErrorResults{err}
	return e.mock
}

// Times sets number of times OutboxRepository.UpdateError should be invoked
func (mmUpdateError *mOutboxRepositoryMockUpdateError) Times(n uint64) *mOutboxRepositoryMockUpdateError {
	if n == 0 {
		mmUpdateError.mock.t.Fatalf("Times of OutboxRepositoryMock.UpdateError mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateError.expectedInvocations, n)
	mmUpdateError.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateError
}

func (mmUpdateError *mOutboxRepositoryMockUpdateError) invocationsDone() bool {
	if len(mmUpdateError.expectations) == 0 && mmUpdateError.defaultExpectation == nil && mmUpdateError.mock.funcUpdateError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateError.mock.afterUpdateErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateError implements mm_repositories.OutboxRepository
func (mmUpdateError *OutboxRepositoryMock) UpdateError(ctx context.Context, eventID uint64, errMsg string) (err error) {
	mm_atomic.AddUint64(&mmUpdateError.beforeUpdateErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateError.afterUpdateErrorCounter, 1)

	mmUpdateError.t.Helper()

	if mmUpdateError.inspectFuncUpdateError != nil {
		mmUpdateError.inspectFuncUpdateError(ctx, eventID, errMsg)
	}

	mm_params := OutboxRepositoryMockUpdateErrorParams{ctx, eventID, errMsg}

	// Record call args
	mmUpdateError.UpdateErrorMock.mutex.Lock()
	mmUpdateError.UpdateErrorMock.callArgs = append(mmUpdateError.UpdateErrorMock.callArgs, &mm_params)
	mmUpdateError.UpdateErrorMock.mutex.Unlock()

	for _, e := range mmUpdateError.UpdateErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateError.UpdateErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateError.UpdateErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateError.UpdateErrorMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateError.UpdateErrorMock.defaultExpectation.paramPtrs

		mm_got := OutboxRepositoryMockUpdateErrorParams{ctx, eventID, errMsg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateError.t.Errorf("OutboxRepositoryMock.UpdateError got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateError.UpdateErrorMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.eventID != nil && !minimock.Equal(*mm_want_ptrs.eventID, mm_got.eventID) {
				mmUpdateError.t.Errorf("OutboxRepositoryMock.UpdateError got unexpected parameter eventID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateError.UpdateErrorMock.defaultExpectation.expectationOrigins.originEventID, *mm_want_ptrs.eventID, mm_got.eventID, minimock.Diff(*mm_want_ptrs.eventID, mm_got.eventID))
			}

			if mm_want_ptrs.errMsg != nil && !minimock.Equal(*mm_want_ptrs.errMsg, mm_got.errMsg) {
				mmUpdateError.t.Errorf("OutboxRepositoryMock.UpdateError got unexpected parameter errMsg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateError.UpdateErrorMock.defaultExpectation.expectationOrigins.originErrMsg, *mm_want_ptrs.errMsg, mm_got.errMsg, minimock.Diff(*mm_want_ptrs.errMsg, mm_got.errMsg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateError.t.Errorf("OutboxRepositoryMock.UpdateError got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateError.UpdateErrorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateError.UpdateErrorMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateError.t.Fatal("No results are set for the OutboxRepositoryMock.UpdateError")
		}
		return (*mm_results).err
	}
	if mmUpdateError.funcUpdateError != nil {
		return mmUpdateError.funcUpdateError(ctx, eventID, errMsg)
	}
	mmUpdateError.t.Fatalf("Unexpected call to OutboxRepositoryMock.UpdateError. %v %v %v", ctx, eventID, errMsg)
	return
}

// UpdateErrorAfterCounter returns a count of finished OutboxRepositoryMock.UpdateError invocations
func (mmUpdateError *OutboxRepositoryMock) UpdateErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateError.afterUpdateErrorCounter)
}

// UpdateErrorBeforeCounter returns a count of OutboxRepositoryMock.UpdateError invocations
func (mmUpdateError *OutboxRepositoryMock) UpdateErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateError.beforeUpdateErrorCounter)
}

// Calls returns a list of arguments used in each call to OutboxRepositoryMock.UpdateError.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateError *mOutboxRepositoryMockUpdateError) Calls() []*OutboxRepositoryMockUpdateErrorParams {
	mmUpdateError.mutex.RLock()

	argCopy := make([]*OutboxRepositoryMockUpdateErrorParams, len(mmUpdateError.callArgs))
	copy(argCopy, mmUpdateError.callArgs)

	mmUpdateError.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateErrorDone returns true if the count of the UpdateError invocations corresponds
// the number of defined expectations
func (m *OutboxRepositoryMock) MinimockUpdateErrorDone() bool {
	if m.UpdateErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateErrorMock.invocationsDone()
}

// MinimockUpdateErrorInspect logs each unmet expectation
func (m *OutboxRepositoryMock) MinimockUpdateErrorInspect() {
	for _, e := range m.UpdateErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OutboxRepositoryMock.UpdateError at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateErrorCounter := mm_atomic.LoadUint64(&m.afterUpdateErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateErrorMock.defaultExpectation != nil && afterUpdateErrorCounter < 1 {
		if m.UpdateErrorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OutboxRepositoryMock.UpdateError at\n%s", m.UpdateErrorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OutboxRepositoryMock.UpdateError at\n%s with params: %#v", m.UpdateErrorMock.defaultExpectation.expectationOrigins.origin, *m.UpdateErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateError != nil && afterUpdateErrorCounter < 1 {
		m.t.Errorf("Expected call to OutboxRepositoryMock.UpdateError at\n%s", m.funcUpdateErrorOrigin)
	}

	if !m.UpdateErrorMock.invocationsDone() && afterUpdateErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to OutboxRepositoryMock.UpdateError at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateErrorMock.expectedInvocations), m.UpdateErrorMock.expectedInvocationsOrigin, afterUpdateErrorCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OutboxRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetProcessingEventsInspect()

			m.MinimockSetCompletedInspect()

			m.MinimockSetFailedInspect()

			m.MinimockSetProcessingInspect()

			m.MinimockUpdateErrorInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OutboxRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OutboxRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetProcessingEventsDone() &&
		m.MinimockSetCompletedDone() &&
		m.MinimockSetFailedDone() &&
		m.MinimockSetProcessingDone() &&
		m.MinimockUpdateErrorDone()
}
