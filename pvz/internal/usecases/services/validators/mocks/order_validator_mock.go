// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"pvz-cli/internal/models"
	"pvz-cli/internal/usecases/requests"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderValidatorMock implements mm_validators.OrderValidator
type OrderValidatorMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcValidateAccept          func(o models.Order, req requests.AcceptOrderRequest) (err error)
	funcValidateAcceptOrigin    string
	inspectFuncValidateAccept   func(o models.Order, req requests.AcceptOrderRequest)
	afterValidateAcceptCounter  uint64
	beforeValidateAcceptCounter uint64
	ValidateAcceptMock          mOrderValidatorMockValidateAccept

	funcValidateClientReturn          func(order models.Order, req requests.ClientReturnsRequest) (err error)
	funcValidateClientReturnOrigin    string
	inspectFuncValidateClientReturn   func(order models.Order, req requests.ClientReturnsRequest)
	afterValidateClientReturnCounter  uint64
	beforeValidateClientReturnCounter uint64
	ValidateClientReturnMock          mOrderValidatorMockValidateClientReturn

	funcValidateIssue          func(o models.Order, req requests.IssueOrdersRequest) (err error)
	funcValidateIssueOrigin    string
	inspectFuncValidateIssue   func(o models.Order, req requests.IssueOrdersRequest)
	afterValidateIssueCounter  uint64
	beforeValidateIssueCounter uint64
	ValidateIssueMock          mOrderValidatorMockValidateIssue

	funcValidateReturnToCourier          func(o models.Order) (err error)
	funcValidateReturnToCourierOrigin    string
	inspectFuncValidateReturnToCourier   func(o models.Order)
	afterValidateReturnToCourierCounter  uint64
	beforeValidateReturnToCourierCounter uint64
	ValidateReturnToCourierMock          mOrderValidatorMockValidateReturnToCourier
}

// NewOrderValidatorMock returns a mock for mm_validators.OrderValidator
func NewOrderValidatorMock(t minimock.Tester) *OrderValidatorMock {
	m := &OrderValidatorMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ValidateAcceptMock = mOrderValidatorMockValidateAccept{mock: m}
	m.ValidateAcceptMock.callArgs = []*OrderValidatorMockValidateAcceptParams{}

	m.ValidateClientReturnMock = mOrderValidatorMockValidateClientReturn{mock: m}
	m.ValidateClientReturnMock.callArgs = []*OrderValidatorMockValidateClientReturnParams{}

	m.ValidateIssueMock = mOrderValidatorMockValidateIssue{mock: m}
	m.ValidateIssueMock.callArgs = []*OrderValidatorMockValidateIssueParams{}

	m.ValidateReturnToCourierMock = mOrderValidatorMockValidateReturnToCourier{mock: m}
	m.ValidateReturnToCourierMock.callArgs = []*OrderValidatorMockValidateReturnToCourierParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderValidatorMockValidateAccept struct {
	optional           bool
	mock               *OrderValidatorMock
	defaultExpectation *OrderValidatorMockValidateAcceptExpectation
	expectations       []*OrderValidatorMockValidateAcceptExpectation

	callArgs []*OrderValidatorMockValidateAcceptParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderValidatorMockValidateAcceptExpectation specifies expectation struct of the OrderValidator.ValidateAccept
type OrderValidatorMockValidateAcceptExpectation struct {
	mock               *OrderValidatorMock
	params             *OrderValidatorMockValidateAcceptParams
	paramPtrs          *OrderValidatorMockValidateAcceptParamPtrs
	expectationOrigins OrderValidatorMockValidateAcceptExpectationOrigins
	results            *OrderValidatorMockValidateAcceptResults
	returnOrigin       string
	Counter            uint64
}

// OrderValidatorMockValidateAcceptParams contains parameters of the OrderValidator.ValidateAccept
type OrderValidatorMockValidateAcceptParams struct {
	o   models.Order
	req requests.AcceptOrderRequest
}

// OrderValidatorMockValidateAcceptParamPtrs contains pointers to parameters of the OrderValidator.ValidateAccept
type OrderValidatorMockValidateAcceptParamPtrs struct {
	o   *models.Order
	req *requests.AcceptOrderRequest
}

// OrderValidatorMockValidateAcceptResults contains results of the OrderValidator.ValidateAccept
type OrderValidatorMockValidateAcceptResults struct {
	err error
}

// OrderValidatorMockValidateAcceptOrigins contains origins of expectations of the OrderValidator.ValidateAccept
type OrderValidatorMockValidateAcceptExpectationOrigins struct {
	origin    string
	originO   string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateAccept *mOrderValidatorMockValidateAccept) Optional() *mOrderValidatorMockValidateAccept {
	mmValidateAccept.optional = true
	return mmValidateAccept
}

// Expect sets up expected params for OrderValidator.ValidateAccept
func (mmValidateAccept *mOrderValidatorMockValidateAccept) Expect(o models.Order, req requests.AcceptOrderRequest) *mOrderValidatorMockValidateAccept {
	if mmValidateAccept.mock.funcValidateAccept != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by Set")
	}

	if mmValidateAccept.defaultExpectation == nil {
		mmValidateAccept.defaultExpectation = &OrderValidatorMockValidateAcceptExpectation{}
	}

	if mmValidateAccept.defaultExpectation.paramPtrs != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by ExpectParams functions")
	}

	mmValidateAccept.defaultExpectation.params = &OrderValidatorMockValidateAcceptParams{o, req}
	mmValidateAccept.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateAccept.expectations {
		if minimock.Equal(e.params, mmValidateAccept.defaultExpectation.params) {
			mmValidateAccept.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateAccept.defaultExpectation.params)
		}
	}

	return mmValidateAccept
}

// ExpectOParam1 sets up expected param o for OrderValidator.ValidateAccept
func (mmValidateAccept *mOrderValidatorMockValidateAccept) ExpectOParam1(o models.Order) *mOrderValidatorMockValidateAccept {
	if mmValidateAccept.mock.funcValidateAccept != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by Set")
	}

	if mmValidateAccept.defaultExpectation == nil {
		mmValidateAccept.defaultExpectation = &OrderValidatorMockValidateAcceptExpectation{}
	}

	if mmValidateAccept.defaultExpectation.params != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by Expect")
	}

	if mmValidateAccept.defaultExpectation.paramPtrs == nil {
		mmValidateAccept.defaultExpectation.paramPtrs = &OrderValidatorMockValidateAcceptParamPtrs{}
	}
	mmValidateAccept.defaultExpectation.paramPtrs.o = &o
	mmValidateAccept.defaultExpectation.expectationOrigins.originO = minimock.CallerInfo(1)

	return mmValidateAccept
}

// ExpectReqParam2 sets up expected param req for OrderValidator.ValidateAccept
func (mmValidateAccept *mOrderValidatorMockValidateAccept) ExpectReqParam2(req requests.AcceptOrderRequest) *mOrderValidatorMockValidateAccept {
	if mmValidateAccept.mock.funcValidateAccept != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by Set")
	}

	if mmValidateAccept.defaultExpectation == nil {
		mmValidateAccept.defaultExpectation = &OrderValidatorMockValidateAcceptExpectation{}
	}

	if mmValidateAccept.defaultExpectation.params != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by Expect")
	}

	if mmValidateAccept.defaultExpectation.paramPtrs == nil {
		mmValidateAccept.defaultExpectation.paramPtrs = &OrderValidatorMockValidateAcceptParamPtrs{}
	}
	mmValidateAccept.defaultExpectation.paramPtrs.req = &req
	mmValidateAccept.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmValidateAccept
}

// Inspect accepts an inspector function that has same arguments as the OrderValidator.ValidateAccept
func (mmValidateAccept *mOrderValidatorMockValidateAccept) Inspect(f func(o models.Order, req requests.AcceptOrderRequest)) *mOrderValidatorMockValidateAccept {
	if mmValidateAccept.mock.inspectFuncValidateAccept != nil {
		mmValidateAccept.mock.t.Fatalf("Inspect function is already set for OrderValidatorMock.ValidateAccept")
	}

	mmValidateAccept.mock.inspectFuncValidateAccept = f

	return mmValidateAccept
}

// Return sets up results that will be returned by OrderValidator.ValidateAccept
func (mmValidateAccept *mOrderValidatorMockValidateAccept) Return(err error) *OrderValidatorMock {
	if mmValidateAccept.mock.funcValidateAccept != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by Set")
	}

	if mmValidateAccept.defaultExpectation == nil {
		mmValidateAccept.defaultExpectation = &OrderValidatorMockValidateAcceptExpectation{mock: mmValidateAccept.mock}
	}
	mmValidateAccept.defaultExpectation.results = &OrderValidatorMockValidateAcceptResults{err}
	mmValidateAccept.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateAccept.mock
}

// Set uses given function f to mock the OrderValidator.ValidateAccept method
func (mmValidateAccept *mOrderValidatorMockValidateAccept) Set(f func(o models.Order, req requests.AcceptOrderRequest) (err error)) *OrderValidatorMock {
	if mmValidateAccept.defaultExpectation != nil {
		mmValidateAccept.mock.t.Fatalf("Default expectation is already set for the OrderValidator.ValidateAccept method")
	}

	if len(mmValidateAccept.expectations) > 0 {
		mmValidateAccept.mock.t.Fatalf("Some expectations are already set for the OrderValidator.ValidateAccept method")
	}

	mmValidateAccept.mock.funcValidateAccept = f
	mmValidateAccept.mock.funcValidateAcceptOrigin = minimock.CallerInfo(1)
	return mmValidateAccept.mock
}

// When sets expectation for the OrderValidator.ValidateAccept which will trigger the result defined by the following
// Then helper
func (mmValidateAccept *mOrderValidatorMockValidateAccept) When(o models.Order, req requests.AcceptOrderRequest) *OrderValidatorMockValidateAcceptExpectation {
	if mmValidateAccept.mock.funcValidateAccept != nil {
		mmValidateAccept.mock.t.Fatalf("OrderValidatorMock.ValidateAccept mock is already set by Set")
	}

	expectation := &OrderValidatorMockValidateAcceptExpectation{
		mock:               mmValidateAccept.mock,
		params:             &OrderValidatorMockValidateAcceptParams{o, req},
		expectationOrigins: OrderValidatorMockValidateAcceptExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateAccept.expectations = append(mmValidateAccept.expectations, expectation)
	return expectation
}

// Then sets up OrderValidator.ValidateAccept return parameters for the expectation previously defined by the When method
func (e *OrderValidatorMockValidateAcceptExpectation) Then(err error) *OrderValidatorMock {
	e.results = &OrderValidatorMockValidateAcceptResults{err}
	return e.mock
}

// Times sets number of times OrderValidator.ValidateAccept should be invoked
func (mmValidateAccept *mOrderValidatorMockValidateAccept) Times(n uint64) *mOrderValidatorMockValidateAccept {
	if n == 0 {
		mmValidateAccept.mock.t.Fatalf("Times of OrderValidatorMock.ValidateAccept mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateAccept.expectedInvocations, n)
	mmValidateAccept.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateAccept
}

func (mmValidateAccept *mOrderValidatorMockValidateAccept) invocationsDone() bool {
	if len(mmValidateAccept.expectations) == 0 && mmValidateAccept.defaultExpectation == nil && mmValidateAccept.mock.funcValidateAccept == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateAccept.mock.afterValidateAcceptCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateAccept.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateAccept implements mm_validators.OrderValidator
func (mmValidateAccept *OrderValidatorMock) ValidateAccept(o models.Order, req requests.AcceptOrderRequest) (err error) {
	mm_atomic.AddUint64(&mmValidateAccept.beforeValidateAcceptCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateAccept.afterValidateAcceptCounter, 1)

	mmValidateAccept.t.Helper()

	if mmValidateAccept.inspectFuncValidateAccept != nil {
		mmValidateAccept.inspectFuncValidateAccept(o, req)
	}

	mm_params := OrderValidatorMockValidateAcceptParams{o, req}

	// Record call args
	mmValidateAccept.ValidateAcceptMock.mutex.Lock()
	mmValidateAccept.ValidateAcceptMock.callArgs = append(mmValidateAccept.ValidateAcceptMock.callArgs, &mm_params)
	mmValidateAccept.ValidateAcceptMock.mutex.Unlock()

	for _, e := range mmValidateAccept.ValidateAcceptMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateAccept.ValidateAcceptMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateAccept.ValidateAcceptMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateAccept.ValidateAcceptMock.defaultExpectation.params
		mm_want_ptrs := mmValidateAccept.ValidateAcceptMock.defaultExpectation.paramPtrs

		mm_got := OrderValidatorMockValidateAcceptParams{o, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.o != nil && !minimock.Equal(*mm_want_ptrs.o, mm_got.o) {
				mmValidateAccept.t.Errorf("OrderValidatorMock.ValidateAccept got unexpected parameter o, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateAccept.ValidateAcceptMock.defaultExpectation.expectationOrigins.originO, *mm_want_ptrs.o, mm_got.o, minimock.Diff(*mm_want_ptrs.o, mm_got.o))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmValidateAccept.t.Errorf("OrderValidatorMock.ValidateAccept got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateAccept.ValidateAcceptMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateAccept.t.Errorf("OrderValidatorMock.ValidateAccept got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateAccept.ValidateAcceptMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateAccept.ValidateAcceptMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateAccept.t.Fatal("No results are set for the OrderValidatorMock.ValidateAccept")
		}
		return (*mm_results).err
	}
	if mmValidateAccept.funcValidateAccept != nil {
		return mmValidateAccept.funcValidateAccept(o, req)
	}
	mmValidateAccept.t.Fatalf("Unexpected call to OrderValidatorMock.ValidateAccept. %v %v", o, req)
	return
}

// ValidateAcceptAfterCounter returns a count of finished OrderValidatorMock.ValidateAccept invocations
func (mmValidateAccept *OrderValidatorMock) ValidateAcceptAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateAccept.afterValidateAcceptCounter)
}

// ValidateAcceptBeforeCounter returns a count of OrderValidatorMock.ValidateAccept invocations
func (mmValidateAccept *OrderValidatorMock) ValidateAcceptBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateAccept.beforeValidateAcceptCounter)
}

// Calls returns a list of arguments used in each call to OrderValidatorMock.ValidateAccept.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateAccept *mOrderValidatorMockValidateAccept) Calls() []*OrderValidatorMockValidateAcceptParams {
	mmValidateAccept.mutex.RLock()

	argCopy := make([]*OrderValidatorMockValidateAcceptParams, len(mmValidateAccept.callArgs))
	copy(argCopy, mmValidateAccept.callArgs)

	mmValidateAccept.mutex.RUnlock()

	return argCopy
}

// MinimockValidateAcceptDone returns true if the count of the ValidateAccept invocations corresponds
// the number of defined expectations
func (m *OrderValidatorMock) MinimockValidateAcceptDone() bool {
	if m.ValidateAcceptMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateAcceptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateAcceptMock.invocationsDone()
}

// MinimockValidateAcceptInspect logs each unmet expectation
func (m *OrderValidatorMock) MinimockValidateAcceptInspect() {
	for _, e := range m.ValidateAcceptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateAccept at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateAcceptCounter := mm_atomic.LoadUint64(&m.afterValidateAcceptCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateAcceptMock.defaultExpectation != nil && afterValidateAcceptCounter < 1 {
		if m.ValidateAcceptMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateAccept at\n%s", m.ValidateAcceptMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateAccept at\n%s with params: %#v", m.ValidateAcceptMock.defaultExpectation.expectationOrigins.origin, *m.ValidateAcceptMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateAccept != nil && afterValidateAcceptCounter < 1 {
		m.t.Errorf("Expected call to OrderValidatorMock.ValidateAccept at\n%s", m.funcValidateAcceptOrigin)
	}

	if !m.ValidateAcceptMock.invocationsDone() && afterValidateAcceptCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderValidatorMock.ValidateAccept at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateAcceptMock.expectedInvocations), m.ValidateAcceptMock.expectedInvocationsOrigin, afterValidateAcceptCounter)
	}
}

type mOrderValidatorMockValidateClientReturn struct {
	optional           bool
	mock               *OrderValidatorMock
	defaultExpectation *OrderValidatorMockValidateClientReturnExpectation
	expectations       []*OrderValidatorMockValidateClientReturnExpectation

	callArgs []*OrderValidatorMockValidateClientReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderValidatorMockValidateClientReturnExpectation specifies expectation struct of the OrderValidator.ValidateClientReturn
type OrderValidatorMockValidateClientReturnExpectation struct {
	mock               *OrderValidatorMock
	params             *OrderValidatorMockValidateClientReturnParams
	paramPtrs          *OrderValidatorMockValidateClientReturnParamPtrs
	expectationOrigins OrderValidatorMockValidateClientReturnExpectationOrigins
	results            *OrderValidatorMockValidateClientReturnResults
	returnOrigin       string
	Counter            uint64
}

// OrderValidatorMockValidateClientReturnParams contains parameters of the OrderValidator.ValidateClientReturn
type OrderValidatorMockValidateClientReturnParams struct {
	order models.Order
	req   requests.ClientReturnsRequest
}

// OrderValidatorMockValidateClientReturnParamPtrs contains pointers to parameters of the OrderValidator.ValidateClientReturn
type OrderValidatorMockValidateClientReturnParamPtrs struct {
	order *models.Order
	req   *requests.ClientReturnsRequest
}

// OrderValidatorMockValidateClientReturnResults contains results of the OrderValidator.ValidateClientReturn
type OrderValidatorMockValidateClientReturnResults struct {
	err error
}

// OrderValidatorMockValidateClientReturnOrigins contains origins of expectations of the OrderValidator.ValidateClientReturn
type OrderValidatorMockValidateClientReturnExpectationOrigins struct {
	origin      string
	originOrder string
	originReq   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) Optional() *mOrderValidatorMockValidateClientReturn {
	mmValidateClientReturn.optional = true
	return mmValidateClientReturn
}

// Expect sets up expected params for OrderValidator.ValidateClientReturn
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) Expect(order models.Order, req requests.ClientReturnsRequest) *mOrderValidatorMockValidateClientReturn {
	if mmValidateClientReturn.mock.funcValidateClientReturn != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by Set")
	}

	if mmValidateClientReturn.defaultExpectation == nil {
		mmValidateClientReturn.defaultExpectation = &OrderValidatorMockValidateClientReturnExpectation{}
	}

	if mmValidateClientReturn.defaultExpectation.paramPtrs != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by ExpectParams functions")
	}

	mmValidateClientReturn.defaultExpectation.params = &OrderValidatorMockValidateClientReturnParams{order, req}
	mmValidateClientReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateClientReturn.expectations {
		if minimock.Equal(e.params, mmValidateClientReturn.defaultExpectation.params) {
			mmValidateClientReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateClientReturn.defaultExpectation.params)
		}
	}

	return mmValidateClientReturn
}

// ExpectOrderParam1 sets up expected param order for OrderValidator.ValidateClientReturn
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) ExpectOrderParam1(order models.Order) *mOrderValidatorMockValidateClientReturn {
	if mmValidateClientReturn.mock.funcValidateClientReturn != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by Set")
	}

	if mmValidateClientReturn.defaultExpectation == nil {
		mmValidateClientReturn.defaultExpectation = &OrderValidatorMockValidateClientReturnExpectation{}
	}

	if mmValidateClientReturn.defaultExpectation.params != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by Expect")
	}

	if mmValidateClientReturn.defaultExpectation.paramPtrs == nil {
		mmValidateClientReturn.defaultExpectation.paramPtrs = &OrderValidatorMockValidateClientReturnParamPtrs{}
	}
	mmValidateClientReturn.defaultExpectation.paramPtrs.order = &order
	mmValidateClientReturn.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmValidateClientReturn
}

// ExpectReqParam2 sets up expected param req for OrderValidator.ValidateClientReturn
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) ExpectReqParam2(req requests.ClientReturnsRequest) *mOrderValidatorMockValidateClientReturn {
	if mmValidateClientReturn.mock.funcValidateClientReturn != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by Set")
	}

	if mmValidateClientReturn.defaultExpectation == nil {
		mmValidateClientReturn.defaultExpectation = &OrderValidatorMockValidateClientReturnExpectation{}
	}

	if mmValidateClientReturn.defaultExpectation.params != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by Expect")
	}

	if mmValidateClientReturn.defaultExpectation.paramPtrs == nil {
		mmValidateClientReturn.defaultExpectation.paramPtrs = &OrderValidatorMockValidateClientReturnParamPtrs{}
	}
	mmValidateClientReturn.defaultExpectation.paramPtrs.req = &req
	mmValidateClientReturn.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmValidateClientReturn
}

// Inspect accepts an inspector function that has same arguments as the OrderValidator.ValidateClientReturn
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) Inspect(f func(order models.Order, req requests.ClientReturnsRequest)) *mOrderValidatorMockValidateClientReturn {
	if mmValidateClientReturn.mock.inspectFuncValidateClientReturn != nil {
		mmValidateClientReturn.mock.t.Fatalf("Inspect function is already set for OrderValidatorMock.ValidateClientReturn")
	}

	mmValidateClientReturn.mock.inspectFuncValidateClientReturn = f

	return mmValidateClientReturn
}

// Return sets up results that will be returned by OrderValidator.ValidateClientReturn
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) Return(err error) *OrderValidatorMock {
	if mmValidateClientReturn.mock.funcValidateClientReturn != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by Set")
	}

	if mmValidateClientReturn.defaultExpectation == nil {
		mmValidateClientReturn.defaultExpectation = &OrderValidatorMockValidateClientReturnExpectation{mock: mmValidateClientReturn.mock}
	}
	mmValidateClientReturn.defaultExpectation.results = &OrderValidatorMockValidateClientReturnResults{err}
	mmValidateClientReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateClientReturn.mock
}

// Set uses given function f to mock the OrderValidator.ValidateClientReturn method
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) Set(f func(order models.Order, req requests.ClientReturnsRequest) (err error)) *OrderValidatorMock {
	if mmValidateClientReturn.defaultExpectation != nil {
		mmValidateClientReturn.mock.t.Fatalf("Default expectation is already set for the OrderValidator.ValidateClientReturn method")
	}

	if len(mmValidateClientReturn.expectations) > 0 {
		mmValidateClientReturn.mock.t.Fatalf("Some expectations are already set for the OrderValidator.ValidateClientReturn method")
	}

	mmValidateClientReturn.mock.funcValidateClientReturn = f
	mmValidateClientReturn.mock.funcValidateClientReturnOrigin = minimock.CallerInfo(1)
	return mmValidateClientReturn.mock
}

// When sets expectation for the OrderValidator.ValidateClientReturn which will trigger the result defined by the following
// Then helper
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) When(order models.Order, req requests.ClientReturnsRequest) *OrderValidatorMockValidateClientReturnExpectation {
	if mmValidateClientReturn.mock.funcValidateClientReturn != nil {
		mmValidateClientReturn.mock.t.Fatalf("OrderValidatorMock.ValidateClientReturn mock is already set by Set")
	}

	expectation := &OrderValidatorMockValidateClientReturnExpectation{
		mock:               mmValidateClientReturn.mock,
		params:             &OrderValidatorMockValidateClientReturnParams{order, req},
		expectationOrigins: OrderValidatorMockValidateClientReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateClientReturn.expectations = append(mmValidateClientReturn.expectations, expectation)
	return expectation
}

// Then sets up OrderValidator.ValidateClientReturn return parameters for the expectation previously defined by the When method
func (e *OrderValidatorMockValidateClientReturnExpectation) Then(err error) *OrderValidatorMock {
	e.results = &OrderValidatorMockValidateClientReturnResults{err}
	return e.mock
}

// Times sets number of times OrderValidator.ValidateClientReturn should be invoked
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) Times(n uint64) *mOrderValidatorMockValidateClientReturn {
	if n == 0 {
		mmValidateClientReturn.mock.t.Fatalf("Times of OrderValidatorMock.ValidateClientReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateClientReturn.expectedInvocations, n)
	mmValidateClientReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateClientReturn
}

func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) invocationsDone() bool {
	if len(mmValidateClientReturn.expectations) == 0 && mmValidateClientReturn.defaultExpectation == nil && mmValidateClientReturn.mock.funcValidateClientReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateClientReturn.mock.afterValidateClientReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateClientReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateClientReturn implements mm_validators.OrderValidator
func (mmValidateClientReturn *OrderValidatorMock) ValidateClientReturn(order models.Order, req requests.ClientReturnsRequest) (err error) {
	mm_atomic.AddUint64(&mmValidateClientReturn.beforeValidateClientReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateClientReturn.afterValidateClientReturnCounter, 1)

	mmValidateClientReturn.t.Helper()

	if mmValidateClientReturn.inspectFuncValidateClientReturn != nil {
		mmValidateClientReturn.inspectFuncValidateClientReturn(order, req)
	}

	mm_params := OrderValidatorMockValidateClientReturnParams{order, req}

	// Record call args
	mmValidateClientReturn.ValidateClientReturnMock.mutex.Lock()
	mmValidateClientReturn.ValidateClientReturnMock.callArgs = append(mmValidateClientReturn.ValidateClientReturnMock.callArgs, &mm_params)
	mmValidateClientReturn.ValidateClientReturnMock.mutex.Unlock()

	for _, e := range mmValidateClientReturn.ValidateClientReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation.params
		mm_want_ptrs := mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation.paramPtrs

		mm_got := OrderValidatorMockValidateClientReturnParams{order, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmValidateClientReturn.t.Errorf("OrderValidatorMock.ValidateClientReturn got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmValidateClientReturn.t.Errorf("OrderValidatorMock.ValidateClientReturn got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateClientReturn.t.Errorf("OrderValidatorMock.ValidateClientReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateClientReturn.ValidateClientReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateClientReturn.t.Fatal("No results are set for the OrderValidatorMock.ValidateClientReturn")
		}
		return (*mm_results).err
	}
	if mmValidateClientReturn.funcValidateClientReturn != nil {
		return mmValidateClientReturn.funcValidateClientReturn(order, req)
	}
	mmValidateClientReturn.t.Fatalf("Unexpected call to OrderValidatorMock.ValidateClientReturn. %v %v", order, req)
	return
}

// ValidateClientReturnAfterCounter returns a count of finished OrderValidatorMock.ValidateClientReturn invocations
func (mmValidateClientReturn *OrderValidatorMock) ValidateClientReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateClientReturn.afterValidateClientReturnCounter)
}

// ValidateClientReturnBeforeCounter returns a count of OrderValidatorMock.ValidateClientReturn invocations
func (mmValidateClientReturn *OrderValidatorMock) ValidateClientReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateClientReturn.beforeValidateClientReturnCounter)
}

// Calls returns a list of arguments used in each call to OrderValidatorMock.ValidateClientReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateClientReturn *mOrderValidatorMockValidateClientReturn) Calls() []*OrderValidatorMockValidateClientReturnParams {
	mmValidateClientReturn.mutex.RLock()

	argCopy := make([]*OrderValidatorMockValidateClientReturnParams, len(mmValidateClientReturn.callArgs))
	copy(argCopy, mmValidateClientReturn.callArgs)

	mmValidateClientReturn.mutex.RUnlock()

	return argCopy
}

// MinimockValidateClientReturnDone returns true if the count of the ValidateClientReturn invocations corresponds
// the number of defined expectations
func (m *OrderValidatorMock) MinimockValidateClientReturnDone() bool {
	if m.ValidateClientReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateClientReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateClientReturnMock.invocationsDone()
}

// MinimockValidateClientReturnInspect logs each unmet expectation
func (m *OrderValidatorMock) MinimockValidateClientReturnInspect() {
	for _, e := range m.ValidateClientReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateClientReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateClientReturnCounter := mm_atomic.LoadUint64(&m.afterValidateClientReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateClientReturnMock.defaultExpectation != nil && afterValidateClientReturnCounter < 1 {
		if m.ValidateClientReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateClientReturn at\n%s", m.ValidateClientReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateClientReturn at\n%s with params: %#v", m.ValidateClientReturnMock.defaultExpectation.expectationOrigins.origin, *m.ValidateClientReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateClientReturn != nil && afterValidateClientReturnCounter < 1 {
		m.t.Errorf("Expected call to OrderValidatorMock.ValidateClientReturn at\n%s", m.funcValidateClientReturnOrigin)
	}

	if !m.ValidateClientReturnMock.invocationsDone() && afterValidateClientReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderValidatorMock.ValidateClientReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateClientReturnMock.expectedInvocations), m.ValidateClientReturnMock.expectedInvocationsOrigin, afterValidateClientReturnCounter)
	}
}

type mOrderValidatorMockValidateIssue struct {
	optional           bool
	mock               *OrderValidatorMock
	defaultExpectation *OrderValidatorMockValidateIssueExpectation
	expectations       []*OrderValidatorMockValidateIssueExpectation

	callArgs []*OrderValidatorMockValidateIssueParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderValidatorMockValidateIssueExpectation specifies expectation struct of the OrderValidator.ValidateIssue
type OrderValidatorMockValidateIssueExpectation struct {
	mock               *OrderValidatorMock
	params             *OrderValidatorMockValidateIssueParams
	paramPtrs          *OrderValidatorMockValidateIssueParamPtrs
	expectationOrigins OrderValidatorMockValidateIssueExpectationOrigins
	results            *OrderValidatorMockValidateIssueResults
	returnOrigin       string
	Counter            uint64
}

// OrderValidatorMockValidateIssueParams contains parameters of the OrderValidator.ValidateIssue
type OrderValidatorMockValidateIssueParams struct {
	o   models.Order
	req requests.IssueOrdersRequest
}

// OrderValidatorMockValidateIssueParamPtrs contains pointers to parameters of the OrderValidator.ValidateIssue
type OrderValidatorMockValidateIssueParamPtrs struct {
	o   *models.Order
	req *requests.IssueOrdersRequest
}

// OrderValidatorMockValidateIssueResults contains results of the OrderValidator.ValidateIssue
type OrderValidatorMockValidateIssueResults struct {
	err error
}

// OrderValidatorMockValidateIssueOrigins contains origins of expectations of the OrderValidator.ValidateIssue
type OrderValidatorMockValidateIssueExpectationOrigins struct {
	origin    string
	originO   string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateIssue *mOrderValidatorMockValidateIssue) Optional() *mOrderValidatorMockValidateIssue {
	mmValidateIssue.optional = true
	return mmValidateIssue
}

// Expect sets up expected params for OrderValidator.ValidateIssue
func (mmValidateIssue *mOrderValidatorMockValidateIssue) Expect(o models.Order, req requests.IssueOrdersRequest) *mOrderValidatorMockValidateIssue {
	if mmValidateIssue.mock.funcValidateIssue != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by Set")
	}

	if mmValidateIssue.defaultExpectation == nil {
		mmValidateIssue.defaultExpectation = &OrderValidatorMockValidateIssueExpectation{}
	}

	if mmValidateIssue.defaultExpectation.paramPtrs != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by ExpectParams functions")
	}

	mmValidateIssue.defaultExpectation.params = &OrderValidatorMockValidateIssueParams{o, req}
	mmValidateIssue.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateIssue.expectations {
		if minimock.Equal(e.params, mmValidateIssue.defaultExpectation.params) {
			mmValidateIssue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateIssue.defaultExpectation.params)
		}
	}

	return mmValidateIssue
}

// ExpectOParam1 sets up expected param o for OrderValidator.ValidateIssue
func (mmValidateIssue *mOrderValidatorMockValidateIssue) ExpectOParam1(o models.Order) *mOrderValidatorMockValidateIssue {
	if mmValidateIssue.mock.funcValidateIssue != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by Set")
	}

	if mmValidateIssue.defaultExpectation == nil {
		mmValidateIssue.defaultExpectation = &OrderValidatorMockValidateIssueExpectation{}
	}

	if mmValidateIssue.defaultExpectation.params != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by Expect")
	}

	if mmValidateIssue.defaultExpectation.paramPtrs == nil {
		mmValidateIssue.defaultExpectation.paramPtrs = &OrderValidatorMockValidateIssueParamPtrs{}
	}
	mmValidateIssue.defaultExpectation.paramPtrs.o = &o
	mmValidateIssue.defaultExpectation.expectationOrigins.originO = minimock.CallerInfo(1)

	return mmValidateIssue
}

// ExpectReqParam2 sets up expected param req for OrderValidator.ValidateIssue
func (mmValidateIssue *mOrderValidatorMockValidateIssue) ExpectReqParam2(req requests.IssueOrdersRequest) *mOrderValidatorMockValidateIssue {
	if mmValidateIssue.mock.funcValidateIssue != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by Set")
	}

	if mmValidateIssue.defaultExpectation == nil {
		mmValidateIssue.defaultExpectation = &OrderValidatorMockValidateIssueExpectation{}
	}

	if mmValidateIssue.defaultExpectation.params != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by Expect")
	}

	if mmValidateIssue.defaultExpectation.paramPtrs == nil {
		mmValidateIssue.defaultExpectation.paramPtrs = &OrderValidatorMockValidateIssueParamPtrs{}
	}
	mmValidateIssue.defaultExpectation.paramPtrs.req = &req
	mmValidateIssue.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmValidateIssue
}

// Inspect accepts an inspector function that has same arguments as the OrderValidator.ValidateIssue
func (mmValidateIssue *mOrderValidatorMockValidateIssue) Inspect(f func(o models.Order, req requests.IssueOrdersRequest)) *mOrderValidatorMockValidateIssue {
	if mmValidateIssue.mock.inspectFuncValidateIssue != nil {
		mmValidateIssue.mock.t.Fatalf("Inspect function is already set for OrderValidatorMock.ValidateIssue")
	}

	mmValidateIssue.mock.inspectFuncValidateIssue = f

	return mmValidateIssue
}

// Return sets up results that will be returned by OrderValidator.ValidateIssue
func (mmValidateIssue *mOrderValidatorMockValidateIssue) Return(err error) *OrderValidatorMock {
	if mmValidateIssue.mock.funcValidateIssue != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by Set")
	}

	if mmValidateIssue.defaultExpectation == nil {
		mmValidateIssue.defaultExpectation = &OrderValidatorMockValidateIssueExpectation{mock: mmValidateIssue.mock}
	}
	mmValidateIssue.defaultExpectation.results = &OrderValidatorMockValidateIssueResults{err}
	mmValidateIssue.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateIssue.mock
}

// Set uses given function f to mock the OrderValidator.ValidateIssue method
func (mmValidateIssue *mOrderValidatorMockValidateIssue) Set(f func(o models.Order, req requests.IssueOrdersRequest) (err error)) *OrderValidatorMock {
	if mmValidateIssue.defaultExpectation != nil {
		mmValidateIssue.mock.t.Fatalf("Default expectation is already set for the OrderValidator.ValidateIssue method")
	}

	if len(mmValidateIssue.expectations) > 0 {
		mmValidateIssue.mock.t.Fatalf("Some expectations are already set for the OrderValidator.ValidateIssue method")
	}

	mmValidateIssue.mock.funcValidateIssue = f
	mmValidateIssue.mock.funcValidateIssueOrigin = minimock.CallerInfo(1)
	return mmValidateIssue.mock
}

// When sets expectation for the OrderValidator.ValidateIssue which will trigger the result defined by the following
// Then helper
func (mmValidateIssue *mOrderValidatorMockValidateIssue) When(o models.Order, req requests.IssueOrdersRequest) *OrderValidatorMockValidateIssueExpectation {
	if mmValidateIssue.mock.funcValidateIssue != nil {
		mmValidateIssue.mock.t.Fatalf("OrderValidatorMock.ValidateIssue mock is already set by Set")
	}

	expectation := &OrderValidatorMockValidateIssueExpectation{
		mock:               mmValidateIssue.mock,
		params:             &OrderValidatorMockValidateIssueParams{o, req},
		expectationOrigins: OrderValidatorMockValidateIssueExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateIssue.expectations = append(mmValidateIssue.expectations, expectation)
	return expectation
}

// Then sets up OrderValidator.ValidateIssue return parameters for the expectation previously defined by the When method
func (e *OrderValidatorMockValidateIssueExpectation) Then(err error) *OrderValidatorMock {
	e.results = &OrderValidatorMockValidateIssueResults{err}
	return e.mock
}

// Times sets number of times OrderValidator.ValidateIssue should be invoked
func (mmValidateIssue *mOrderValidatorMockValidateIssue) Times(n uint64) *mOrderValidatorMockValidateIssue {
	if n == 0 {
		mmValidateIssue.mock.t.Fatalf("Times of OrderValidatorMock.ValidateIssue mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateIssue.expectedInvocations, n)
	mmValidateIssue.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateIssue
}

func (mmValidateIssue *mOrderValidatorMockValidateIssue) invocationsDone() bool {
	if len(mmValidateIssue.expectations) == 0 && mmValidateIssue.defaultExpectation == nil && mmValidateIssue.mock.funcValidateIssue == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateIssue.mock.afterValidateIssueCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateIssue.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateIssue implements mm_validators.OrderValidator
func (mmValidateIssue *OrderValidatorMock) ValidateIssue(o models.Order, req requests.IssueOrdersRequest) (err error) {
	mm_atomic.AddUint64(&mmValidateIssue.beforeValidateIssueCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateIssue.afterValidateIssueCounter, 1)

	mmValidateIssue.t.Helper()

	if mmValidateIssue.inspectFuncValidateIssue != nil {
		mmValidateIssue.inspectFuncValidateIssue(o, req)
	}

	mm_params := OrderValidatorMockValidateIssueParams{o, req}

	// Record call args
	mmValidateIssue.ValidateIssueMock.mutex.Lock()
	mmValidateIssue.ValidateIssueMock.callArgs = append(mmValidateIssue.ValidateIssueMock.callArgs, &mm_params)
	mmValidateIssue.ValidateIssueMock.mutex.Unlock()

	for _, e := range mmValidateIssue.ValidateIssueMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateIssue.ValidateIssueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateIssue.ValidateIssueMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateIssue.ValidateIssueMock.defaultExpectation.params
		mm_want_ptrs := mmValidateIssue.ValidateIssueMock.defaultExpectation.paramPtrs

		mm_got := OrderValidatorMockValidateIssueParams{o, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.o != nil && !minimock.Equal(*mm_want_ptrs.o, mm_got.o) {
				mmValidateIssue.t.Errorf("OrderValidatorMock.ValidateIssue got unexpected parameter o, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateIssue.ValidateIssueMock.defaultExpectation.expectationOrigins.originO, *mm_want_ptrs.o, mm_got.o, minimock.Diff(*mm_want_ptrs.o, mm_got.o))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmValidateIssue.t.Errorf("OrderValidatorMock.ValidateIssue got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateIssue.ValidateIssueMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateIssue.t.Errorf("OrderValidatorMock.ValidateIssue got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateIssue.ValidateIssueMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateIssue.ValidateIssueMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateIssue.t.Fatal("No results are set for the OrderValidatorMock.ValidateIssue")
		}
		return (*mm_results).err
	}
	if mmValidateIssue.funcValidateIssue != nil {
		return mmValidateIssue.funcValidateIssue(o, req)
	}
	mmValidateIssue.t.Fatalf("Unexpected call to OrderValidatorMock.ValidateIssue. %v %v", o, req)
	return
}

// ValidateIssueAfterCounter returns a count of finished OrderValidatorMock.ValidateIssue invocations
func (mmValidateIssue *OrderValidatorMock) ValidateIssueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateIssue.afterValidateIssueCounter)
}

// ValidateIssueBeforeCounter returns a count of OrderValidatorMock.ValidateIssue invocations
func (mmValidateIssue *OrderValidatorMock) ValidateIssueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateIssue.beforeValidateIssueCounter)
}

// Calls returns a list of arguments used in each call to OrderValidatorMock.ValidateIssue.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateIssue *mOrderValidatorMockValidateIssue) Calls() []*OrderValidatorMockValidateIssueParams {
	mmValidateIssue.mutex.RLock()

	argCopy := make([]*OrderValidatorMockValidateIssueParams, len(mmValidateIssue.callArgs))
	copy(argCopy, mmValidateIssue.callArgs)

	mmValidateIssue.mutex.RUnlock()

	return argCopy
}

// MinimockValidateIssueDone returns true if the count of the ValidateIssue invocations corresponds
// the number of defined expectations
func (m *OrderValidatorMock) MinimockValidateIssueDone() bool {
	if m.ValidateIssueMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateIssueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateIssueMock.invocationsDone()
}

// MinimockValidateIssueInspect logs each unmet expectation
func (m *OrderValidatorMock) MinimockValidateIssueInspect() {
	for _, e := range m.ValidateIssueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateIssue at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateIssueCounter := mm_atomic.LoadUint64(&m.afterValidateIssueCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateIssueMock.defaultExpectation != nil && afterValidateIssueCounter < 1 {
		if m.ValidateIssueMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateIssue at\n%s", m.ValidateIssueMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateIssue at\n%s with params: %#v", m.ValidateIssueMock.defaultExpectation.expectationOrigins.origin, *m.ValidateIssueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateIssue != nil && afterValidateIssueCounter < 1 {
		m.t.Errorf("Expected call to OrderValidatorMock.ValidateIssue at\n%s", m.funcValidateIssueOrigin)
	}

	if !m.ValidateIssueMock.invocationsDone() && afterValidateIssueCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderValidatorMock.ValidateIssue at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateIssueMock.expectedInvocations), m.ValidateIssueMock.expectedInvocationsOrigin, afterValidateIssueCounter)
	}
}

type mOrderValidatorMockValidateReturnToCourier struct {
	optional           bool
	mock               *OrderValidatorMock
	defaultExpectation *OrderValidatorMockValidateReturnToCourierExpectation
	expectations       []*OrderValidatorMockValidateReturnToCourierExpectation

	callArgs []*OrderValidatorMockValidateReturnToCourierParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderValidatorMockValidateReturnToCourierExpectation specifies expectation struct of the OrderValidator.ValidateReturnToCourier
type OrderValidatorMockValidateReturnToCourierExpectation struct {
	mock               *OrderValidatorMock
	params             *OrderValidatorMockValidateReturnToCourierParams
	paramPtrs          *OrderValidatorMockValidateReturnToCourierParamPtrs
	expectationOrigins OrderValidatorMockValidateReturnToCourierExpectationOrigins
	results            *OrderValidatorMockValidateReturnToCourierResults
	returnOrigin       string
	Counter            uint64
}

// OrderValidatorMockValidateReturnToCourierParams contains parameters of the OrderValidator.ValidateReturnToCourier
type OrderValidatorMockValidateReturnToCourierParams struct {
	o models.Order
}

// OrderValidatorMockValidateReturnToCourierParamPtrs contains pointers to parameters of the OrderValidator.ValidateReturnToCourier
type OrderValidatorMockValidateReturnToCourierParamPtrs struct {
	o *models.Order
}

// OrderValidatorMockValidateReturnToCourierResults contains results of the OrderValidator.ValidateReturnToCourier
type OrderValidatorMockValidateReturnToCourierResults struct {
	err error
}

// OrderValidatorMockValidateReturnToCourierOrigins contains origins of expectations of the OrderValidator.ValidateReturnToCourier
type OrderValidatorMockValidateReturnToCourierExpectationOrigins struct {
	origin  string
	originO string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) Optional() *mOrderValidatorMockValidateReturnToCourier {
	mmValidateReturnToCourier.optional = true
	return mmValidateReturnToCourier
}

// Expect sets up expected params for OrderValidator.ValidateReturnToCourier
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) Expect(o models.Order) *mOrderValidatorMockValidateReturnToCourier {
	if mmValidateReturnToCourier.mock.funcValidateReturnToCourier != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("OrderValidatorMock.ValidateReturnToCourier mock is already set by Set")
	}

	if mmValidateReturnToCourier.defaultExpectation == nil {
		mmValidateReturnToCourier.defaultExpectation = &OrderValidatorMockValidateReturnToCourierExpectation{}
	}

	if mmValidateReturnToCourier.defaultExpectation.paramPtrs != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("OrderValidatorMock.ValidateReturnToCourier mock is already set by ExpectParams functions")
	}

	mmValidateReturnToCourier.defaultExpectation.params = &OrderValidatorMockValidateReturnToCourierParams{o}
	mmValidateReturnToCourier.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateReturnToCourier.expectations {
		if minimock.Equal(e.params, mmValidateReturnToCourier.defaultExpectation.params) {
			mmValidateReturnToCourier.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateReturnToCourier.defaultExpectation.params)
		}
	}

	return mmValidateReturnToCourier
}

// ExpectOParam1 sets up expected param o for OrderValidator.ValidateReturnToCourier
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) ExpectOParam1(o models.Order) *mOrderValidatorMockValidateReturnToCourier {
	if mmValidateReturnToCourier.mock.funcValidateReturnToCourier != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("OrderValidatorMock.ValidateReturnToCourier mock is already set by Set")
	}

	if mmValidateReturnToCourier.defaultExpectation == nil {
		mmValidateReturnToCourier.defaultExpectation = &OrderValidatorMockValidateReturnToCourierExpectation{}
	}

	if mmValidateReturnToCourier.defaultExpectation.params != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("OrderValidatorMock.ValidateReturnToCourier mock is already set by Expect")
	}

	if mmValidateReturnToCourier.defaultExpectation.paramPtrs == nil {
		mmValidateReturnToCourier.defaultExpectation.paramPtrs = &OrderValidatorMockValidateReturnToCourierParamPtrs{}
	}
	mmValidateReturnToCourier.defaultExpectation.paramPtrs.o = &o
	mmValidateReturnToCourier.defaultExpectation.expectationOrigins.originO = minimock.CallerInfo(1)

	return mmValidateReturnToCourier
}

// Inspect accepts an inspector function that has same arguments as the OrderValidator.ValidateReturnToCourier
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) Inspect(f func(o models.Order)) *mOrderValidatorMockValidateReturnToCourier {
	if mmValidateReturnToCourier.mock.inspectFuncValidateReturnToCourier != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("Inspect function is already set for OrderValidatorMock.ValidateReturnToCourier")
	}

	mmValidateReturnToCourier.mock.inspectFuncValidateReturnToCourier = f

	return mmValidateReturnToCourier
}

// Return sets up results that will be returned by OrderValidator.ValidateReturnToCourier
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) Return(err error) *OrderValidatorMock {
	if mmValidateReturnToCourier.mock.funcValidateReturnToCourier != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("OrderValidatorMock.ValidateReturnToCourier mock is already set by Set")
	}

	if mmValidateReturnToCourier.defaultExpectation == nil {
		mmValidateReturnToCourier.defaultExpectation = &OrderValidatorMockValidateReturnToCourierExpectation{mock: mmValidateReturnToCourier.mock}
	}
	mmValidateReturnToCourier.defaultExpectation.results = &OrderValidatorMockValidateReturnToCourierResults{err}
	mmValidateReturnToCourier.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateReturnToCourier.mock
}

// Set uses given function f to mock the OrderValidator.ValidateReturnToCourier method
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) Set(f func(o models.Order) (err error)) *OrderValidatorMock {
	if mmValidateReturnToCourier.defaultExpectation != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("Default expectation is already set for the OrderValidator.ValidateReturnToCourier method")
	}

	if len(mmValidateReturnToCourier.expectations) > 0 {
		mmValidateReturnToCourier.mock.t.Fatalf("Some expectations are already set for the OrderValidator.ValidateReturnToCourier method")
	}

	mmValidateReturnToCourier.mock.funcValidateReturnToCourier = f
	mmValidateReturnToCourier.mock.funcValidateReturnToCourierOrigin = minimock.CallerInfo(1)
	return mmValidateReturnToCourier.mock
}

// When sets expectation for the OrderValidator.ValidateReturnToCourier which will trigger the result defined by the following
// Then helper
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) When(o models.Order) *OrderValidatorMockValidateReturnToCourierExpectation {
	if mmValidateReturnToCourier.mock.funcValidateReturnToCourier != nil {
		mmValidateReturnToCourier.mock.t.Fatalf("OrderValidatorMock.ValidateReturnToCourier mock is already set by Set")
	}

	expectation := &OrderValidatorMockValidateReturnToCourierExpectation{
		mock:               mmValidateReturnToCourier.mock,
		params:             &OrderValidatorMockValidateReturnToCourierParams{o},
		expectationOrigins: OrderValidatorMockValidateReturnToCourierExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateReturnToCourier.expectations = append(mmValidateReturnToCourier.expectations, expectation)
	return expectation
}

// Then sets up OrderValidator.ValidateReturnToCourier return parameters for the expectation previously defined by the When method
func (e *OrderValidatorMockValidateReturnToCourierExpectation) Then(err error) *OrderValidatorMock {
	e.results = &OrderValidatorMockValidateReturnToCourierResults{err}
	return e.mock
}

// Times sets number of times OrderValidator.ValidateReturnToCourier should be invoked
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) Times(n uint64) *mOrderValidatorMockValidateReturnToCourier {
	if n == 0 {
		mmValidateReturnToCourier.mock.t.Fatalf("Times of OrderValidatorMock.ValidateReturnToCourier mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateReturnToCourier.expectedInvocations, n)
	mmValidateReturnToCourier.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateReturnToCourier
}

func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) invocationsDone() bool {
	if len(mmValidateReturnToCourier.expectations) == 0 && mmValidateReturnToCourier.defaultExpectation == nil && mmValidateReturnToCourier.mock.funcValidateReturnToCourier == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateReturnToCourier.mock.afterValidateReturnToCourierCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateReturnToCourier.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateReturnToCourier implements mm_validators.OrderValidator
func (mmValidateReturnToCourier *OrderValidatorMock) ValidateReturnToCourier(o models.Order) (err error) {
	mm_atomic.AddUint64(&mmValidateReturnToCourier.beforeValidateReturnToCourierCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateReturnToCourier.afterValidateReturnToCourierCounter, 1)

	mmValidateReturnToCourier.t.Helper()

	if mmValidateReturnToCourier.inspectFuncValidateReturnToCourier != nil {
		mmValidateReturnToCourier.inspectFuncValidateReturnToCourier(o)
	}

	mm_params := OrderValidatorMockValidateReturnToCourierParams{o}

	// Record call args
	mmValidateReturnToCourier.ValidateReturnToCourierMock.mutex.Lock()
	mmValidateReturnToCourier.ValidateReturnToCourierMock.callArgs = append(mmValidateReturnToCourier.ValidateReturnToCourierMock.callArgs, &mm_params)
	mmValidateReturnToCourier.ValidateReturnToCourierMock.mutex.Unlock()

	for _, e := range mmValidateReturnToCourier.ValidateReturnToCourierMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateReturnToCourier.ValidateReturnToCourierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateReturnToCourier.ValidateReturnToCourierMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateReturnToCourier.ValidateReturnToCourierMock.defaultExpectation.params
		mm_want_ptrs := mmValidateReturnToCourier.ValidateReturnToCourierMock.defaultExpectation.paramPtrs

		mm_got := OrderValidatorMockValidateReturnToCourierParams{o}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.o != nil && !minimock.Equal(*mm_want_ptrs.o, mm_got.o) {
				mmValidateReturnToCourier.t.Errorf("OrderValidatorMock.ValidateReturnToCourier got unexpected parameter o, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateReturnToCourier.ValidateReturnToCourierMock.defaultExpectation.expectationOrigins.originO, *mm_want_ptrs.o, mm_got.o, minimock.Diff(*mm_want_ptrs.o, mm_got.o))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateReturnToCourier.t.Errorf("OrderValidatorMock.ValidateReturnToCourier got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateReturnToCourier.ValidateReturnToCourierMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateReturnToCourier.ValidateReturnToCourierMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateReturnToCourier.t.Fatal("No results are set for the OrderValidatorMock.ValidateReturnToCourier")
		}
		return (*mm_results).err
	}
	if mmValidateReturnToCourier.funcValidateReturnToCourier != nil {
		return mmValidateReturnToCourier.funcValidateReturnToCourier(o)
	}
	mmValidateReturnToCourier.t.Fatalf("Unexpected call to OrderValidatorMock.ValidateReturnToCourier. %v", o)
	return
}

// ValidateReturnToCourierAfterCounter returns a count of finished OrderValidatorMock.ValidateReturnToCourier invocations
func (mmValidateReturnToCourier *OrderValidatorMock) ValidateReturnToCourierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateReturnToCourier.afterValidateReturnToCourierCounter)
}

// ValidateReturnToCourierBeforeCounter returns a count of OrderValidatorMock.ValidateReturnToCourier invocations
func (mmValidateReturnToCourier *OrderValidatorMock) ValidateReturnToCourierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateReturnToCourier.beforeValidateReturnToCourierCounter)
}

// Calls returns a list of arguments used in each call to OrderValidatorMock.ValidateReturnToCourier.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateReturnToCourier *mOrderValidatorMockValidateReturnToCourier) Calls() []*OrderValidatorMockValidateReturnToCourierParams {
	mmValidateReturnToCourier.mutex.RLock()

	argCopy := make([]*OrderValidatorMockValidateReturnToCourierParams, len(mmValidateReturnToCourier.callArgs))
	copy(argCopy, mmValidateReturnToCourier.callArgs)

	mmValidateReturnToCourier.mutex.RUnlock()

	return argCopy
}

// MinimockValidateReturnToCourierDone returns true if the count of the ValidateReturnToCourier invocations corresponds
// the number of defined expectations
func (m *OrderValidatorMock) MinimockValidateReturnToCourierDone() bool {
	if m.ValidateReturnToCourierMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateReturnToCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateReturnToCourierMock.invocationsDone()
}

// MinimockValidateReturnToCourierInspect logs each unmet expectation
func (m *OrderValidatorMock) MinimockValidateReturnToCourierInspect() {
	for _, e := range m.ValidateReturnToCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateReturnToCourier at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateReturnToCourierCounter := mm_atomic.LoadUint64(&m.afterValidateReturnToCourierCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateReturnToCourierMock.defaultExpectation != nil && afterValidateReturnToCourierCounter < 1 {
		if m.ValidateReturnToCourierMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateReturnToCourier at\n%s", m.ValidateReturnToCourierMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderValidatorMock.ValidateReturnToCourier at\n%s with params: %#v", m.ValidateReturnToCourierMock.defaultExpectation.expectationOrigins.origin, *m.ValidateReturnToCourierMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateReturnToCourier != nil && afterValidateReturnToCourierCounter < 1 {
		m.t.Errorf("Expected call to OrderValidatorMock.ValidateReturnToCourier at\n%s", m.funcValidateReturnToCourierOrigin)
	}

	if !m.ValidateReturnToCourierMock.invocationsDone() && afterValidateReturnToCourierCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderValidatorMock.ValidateReturnToCourier at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateReturnToCourierMock.expectedInvocations), m.ValidateReturnToCourierMock.expectedInvocationsOrigin, afterValidateReturnToCourierCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderValidatorMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockValidateAcceptInspect()

			m.MinimockValidateClientReturnInspect()

			m.MinimockValidateIssueInspect()

			m.MinimockValidateReturnToCourierInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderValidatorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderValidatorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockValidateAcceptDone() &&
		m.MinimockValidateClientReturnDone() &&
		m.MinimockValidateIssueDone() &&
		m.MinimockValidateReturnToCourierDone()
}
