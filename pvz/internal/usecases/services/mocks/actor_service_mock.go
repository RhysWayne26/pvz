// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"context"
	"pvz-cli/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ActorServiceMock implements mm_services.ActorService
type ActorServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDetermineActor          func(ctx context.Context, event models.EventType, userID uint64) (a1 models.Actor, err error)
	funcDetermineActorOrigin    string
	inspectFuncDetermineActor   func(ctx context.Context, event models.EventType, userID uint64)
	afterDetermineActorCounter  uint64
	beforeDetermineActorCounter uint64
	DetermineActorMock          mActorServiceMockDetermineActor

	funcFindFreeCourier          func(ctx context.Context) (u1 uint64, err error)
	funcFindFreeCourierOrigin    string
	inspectFuncFindFreeCourier   func(ctx context.Context)
	afterFindFreeCourierCounter  uint64
	beforeFindFreeCourierCounter uint64
	FindFreeCourierMock          mActorServiceMockFindFreeCourier
}

// NewActorServiceMock returns a mock for mm_services.ActorService
func NewActorServiceMock(t minimock.Tester) *ActorServiceMock {
	m := &ActorServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DetermineActorMock = mActorServiceMockDetermineActor{mock: m}
	m.DetermineActorMock.callArgs = []*ActorServiceMockDetermineActorParams{}

	m.FindFreeCourierMock = mActorServiceMockFindFreeCourier{mock: m}
	m.FindFreeCourierMock.callArgs = []*ActorServiceMockFindFreeCourierParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mActorServiceMockDetermineActor struct {
	optional           bool
	mock               *ActorServiceMock
	defaultExpectation *ActorServiceMockDetermineActorExpectation
	expectations       []*ActorServiceMockDetermineActorExpectation

	callArgs []*ActorServiceMockDetermineActorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ActorServiceMockDetermineActorExpectation specifies expectation struct of the ActorService.DetermineActor
type ActorServiceMockDetermineActorExpectation struct {
	mock               *ActorServiceMock
	params             *ActorServiceMockDetermineActorParams
	paramPtrs          *ActorServiceMockDetermineActorParamPtrs
	expectationOrigins ActorServiceMockDetermineActorExpectationOrigins
	results            *ActorServiceMockDetermineActorResults
	returnOrigin       string
	Counter            uint64
}

// ActorServiceMockDetermineActorParams contains parameters of the ActorService.DetermineActor
type ActorServiceMockDetermineActorParams struct {
	ctx    context.Context
	event  models.EventType
	userID uint64
}

// ActorServiceMockDetermineActorParamPtrs contains pointers to parameters of the ActorService.DetermineActor
type ActorServiceMockDetermineActorParamPtrs struct {
	ctx    *context.Context
	event  *models.EventType
	userID *uint64
}

// ActorServiceMockDetermineActorResults contains results of the ActorService.DetermineActor
type ActorServiceMockDetermineActorResults struct {
	a1  models.Actor
	err error
}

// ActorServiceMockDetermineActorOrigins contains origins of expectations of the ActorService.DetermineActor
type ActorServiceMockDetermineActorExpectationOrigins struct {
	origin       string
	originCtx    string
	originEvent  string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDetermineActor *mActorServiceMockDetermineActor) Optional() *mActorServiceMockDetermineActor {
	mmDetermineActor.optional = true
	return mmDetermineActor
}

// Expect sets up expected params for ActorService.DetermineActor
func (mmDetermineActor *mActorServiceMockDetermineActor) Expect(ctx context.Context, event models.EventType, userID uint64) *mActorServiceMockDetermineActor {
	if mmDetermineActor.mock.funcDetermineActor != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Set")
	}

	if mmDetermineActor.defaultExpectation == nil {
		mmDetermineActor.defaultExpectation = &ActorServiceMockDetermineActorExpectation{}
	}

	if mmDetermineActor.defaultExpectation.paramPtrs != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by ExpectParams functions")
	}

	mmDetermineActor.defaultExpectation.params = &ActorServiceMockDetermineActorParams{ctx, event, userID}
	mmDetermineActor.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDetermineActor.expectations {
		if minimock.Equal(e.params, mmDetermineActor.defaultExpectation.params) {
			mmDetermineActor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDetermineActor.defaultExpectation.params)
		}
	}

	return mmDetermineActor
}

// ExpectCtxParam1 sets up expected param ctx for ActorService.DetermineActor
func (mmDetermineActor *mActorServiceMockDetermineActor) ExpectCtxParam1(ctx context.Context) *mActorServiceMockDetermineActor {
	if mmDetermineActor.mock.funcDetermineActor != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Set")
	}

	if mmDetermineActor.defaultExpectation == nil {
		mmDetermineActor.defaultExpectation = &ActorServiceMockDetermineActorExpectation{}
	}

	if mmDetermineActor.defaultExpectation.params != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Expect")
	}

	if mmDetermineActor.defaultExpectation.paramPtrs == nil {
		mmDetermineActor.defaultExpectation.paramPtrs = &ActorServiceMockDetermineActorParamPtrs{}
	}
	mmDetermineActor.defaultExpectation.paramPtrs.ctx = &ctx
	mmDetermineActor.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDetermineActor
}

// ExpectEventParam2 sets up expected param event for ActorService.DetermineActor
func (mmDetermineActor *mActorServiceMockDetermineActor) ExpectEventParam2(event models.EventType) *mActorServiceMockDetermineActor {
	if mmDetermineActor.mock.funcDetermineActor != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Set")
	}

	if mmDetermineActor.defaultExpectation == nil {
		mmDetermineActor.defaultExpectation = &ActorServiceMockDetermineActorExpectation{}
	}

	if mmDetermineActor.defaultExpectation.params != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Expect")
	}

	if mmDetermineActor.defaultExpectation.paramPtrs == nil {
		mmDetermineActor.defaultExpectation.paramPtrs = &ActorServiceMockDetermineActorParamPtrs{}
	}
	mmDetermineActor.defaultExpectation.paramPtrs.event = &event
	mmDetermineActor.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmDetermineActor
}

// ExpectUserIDParam3 sets up expected param userID for ActorService.DetermineActor
func (mmDetermineActor *mActorServiceMockDetermineActor) ExpectUserIDParam3(userID uint64) *mActorServiceMockDetermineActor {
	if mmDetermineActor.mock.funcDetermineActor != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Set")
	}

	if mmDetermineActor.defaultExpectation == nil {
		mmDetermineActor.defaultExpectation = &ActorServiceMockDetermineActorExpectation{}
	}

	if mmDetermineActor.defaultExpectation.params != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Expect")
	}

	if mmDetermineActor.defaultExpectation.paramPtrs == nil {
		mmDetermineActor.defaultExpectation.paramPtrs = &ActorServiceMockDetermineActorParamPtrs{}
	}
	mmDetermineActor.defaultExpectation.paramPtrs.userID = &userID
	mmDetermineActor.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDetermineActor
}

// Inspect accepts an inspector function that has same arguments as the ActorService.DetermineActor
func (mmDetermineActor *mActorServiceMockDetermineActor) Inspect(f func(ctx context.Context, event models.EventType, userID uint64)) *mActorServiceMockDetermineActor {
	if mmDetermineActor.mock.inspectFuncDetermineActor != nil {
		mmDetermineActor.mock.t.Fatalf("Inspect function is already set for ActorServiceMock.DetermineActor")
	}

	mmDetermineActor.mock.inspectFuncDetermineActor = f

	return mmDetermineActor
}

// Return sets up results that will be returned by ActorService.DetermineActor
func (mmDetermineActor *mActorServiceMockDetermineActor) Return(a1 models.Actor, err error) *ActorServiceMock {
	if mmDetermineActor.mock.funcDetermineActor != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Set")
	}

	if mmDetermineActor.defaultExpectation == nil {
		mmDetermineActor.defaultExpectation = &ActorServiceMockDetermineActorExpectation{mock: mmDetermineActor.mock}
	}
	mmDetermineActor.defaultExpectation.results = &ActorServiceMockDetermineActorResults{a1, err}
	mmDetermineActor.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDetermineActor.mock
}

// Set uses given function f to mock the ActorService.DetermineActor method
func (mmDetermineActor *mActorServiceMockDetermineActor) Set(f func(ctx context.Context, event models.EventType, userID uint64) (a1 models.Actor, err error)) *ActorServiceMock {
	if mmDetermineActor.defaultExpectation != nil {
		mmDetermineActor.mock.t.Fatalf("Default expectation is already set for the ActorService.DetermineActor method")
	}

	if len(mmDetermineActor.expectations) > 0 {
		mmDetermineActor.mock.t.Fatalf("Some expectations are already set for the ActorService.DetermineActor method")
	}

	mmDetermineActor.mock.funcDetermineActor = f
	mmDetermineActor.mock.funcDetermineActorOrigin = minimock.CallerInfo(1)
	return mmDetermineActor.mock
}

// When sets expectation for the ActorService.DetermineActor which will trigger the result defined by the following
// Then helper
func (mmDetermineActor *mActorServiceMockDetermineActor) When(ctx context.Context, event models.EventType, userID uint64) *ActorServiceMockDetermineActorExpectation {
	if mmDetermineActor.mock.funcDetermineActor != nil {
		mmDetermineActor.mock.t.Fatalf("ActorServiceMock.DetermineActor mock is already set by Set")
	}

	expectation := &ActorServiceMockDetermineActorExpectation{
		mock:               mmDetermineActor.mock,
		params:             &ActorServiceMockDetermineActorParams{ctx, event, userID},
		expectationOrigins: ActorServiceMockDetermineActorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDetermineActor.expectations = append(mmDetermineActor.expectations, expectation)
	return expectation
}

// Then sets up ActorService.DetermineActor return parameters for the expectation previously defined by the When method
func (e *ActorServiceMockDetermineActorExpectation) Then(a1 models.Actor, err error) *ActorServiceMock {
	e.results = &ActorServiceMockDetermineActorResults{a1, err}
	return e.mock
}

// Times sets number of times ActorService.DetermineActor should be invoked
func (mmDetermineActor *mActorServiceMockDetermineActor) Times(n uint64) *mActorServiceMockDetermineActor {
	if n == 0 {
		mmDetermineActor.mock.t.Fatalf("Times of ActorServiceMock.DetermineActor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDetermineActor.expectedInvocations, n)
	mmDetermineActor.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDetermineActor
}

func (mmDetermineActor *mActorServiceMockDetermineActor) invocationsDone() bool {
	if len(mmDetermineActor.expectations) == 0 && mmDetermineActor.defaultExpectation == nil && mmDetermineActor.mock.funcDetermineActor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDetermineActor.mock.afterDetermineActorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDetermineActor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DetermineActor implements mm_services.ActorService
func (mmDetermineActor *ActorServiceMock) DetermineActor(ctx context.Context, event models.EventType, userID uint64) (a1 models.Actor, err error) {
	mm_atomic.AddUint64(&mmDetermineActor.beforeDetermineActorCounter, 1)
	defer mm_atomic.AddUint64(&mmDetermineActor.afterDetermineActorCounter, 1)

	mmDetermineActor.t.Helper()

	if mmDetermineActor.inspectFuncDetermineActor != nil {
		mmDetermineActor.inspectFuncDetermineActor(ctx, event, userID)
	}

	mm_params := ActorServiceMockDetermineActorParams{ctx, event, userID}

	// Record call args
	mmDetermineActor.DetermineActorMock.mutex.Lock()
	mmDetermineActor.DetermineActorMock.callArgs = append(mmDetermineActor.DetermineActorMock.callArgs, &mm_params)
	mmDetermineActor.DetermineActorMock.mutex.Unlock()

	for _, e := range mmDetermineActor.DetermineActorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.a1, e.results.err
		}
	}

	if mmDetermineActor.DetermineActorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDetermineActor.DetermineActorMock.defaultExpectation.Counter, 1)
		mm_want := mmDetermineActor.DetermineActorMock.defaultExpectation.params
		mm_want_ptrs := mmDetermineActor.DetermineActorMock.defaultExpectation.paramPtrs

		mm_got := ActorServiceMockDetermineActorParams{ctx, event, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDetermineActor.t.Errorf("ActorServiceMock.DetermineActor got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDetermineActor.DetermineActorMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmDetermineActor.t.Errorf("ActorServiceMock.DetermineActor got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDetermineActor.DetermineActorMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDetermineActor.t.Errorf("ActorServiceMock.DetermineActor got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDetermineActor.DetermineActorMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDetermineActor.t.Errorf("ActorServiceMock.DetermineActor got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDetermineActor.DetermineActorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDetermineActor.DetermineActorMock.defaultExpectation.results
		if mm_results == nil {
			mmDetermineActor.t.Fatal("No results are set for the ActorServiceMock.DetermineActor")
		}
		return (*mm_results).a1, (*mm_results).err
	}
	if mmDetermineActor.funcDetermineActor != nil {
		return mmDetermineActor.funcDetermineActor(ctx, event, userID)
	}
	mmDetermineActor.t.Fatalf("Unexpected call to ActorServiceMock.DetermineActor. %v %v %v", ctx, event, userID)
	return
}

// DetermineActorAfterCounter returns a count of finished ActorServiceMock.DetermineActor invocations
func (mmDetermineActor *ActorServiceMock) DetermineActorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDetermineActor.afterDetermineActorCounter)
}

// DetermineActorBeforeCounter returns a count of ActorServiceMock.DetermineActor invocations
func (mmDetermineActor *ActorServiceMock) DetermineActorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDetermineActor.beforeDetermineActorCounter)
}

// Calls returns a list of arguments used in each call to ActorServiceMock.DetermineActor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDetermineActor *mActorServiceMockDetermineActor) Calls() []*ActorServiceMockDetermineActorParams {
	mmDetermineActor.mutex.RLock()

	argCopy := make([]*ActorServiceMockDetermineActorParams, len(mmDetermineActor.callArgs))
	copy(argCopy, mmDetermineActor.callArgs)

	mmDetermineActor.mutex.RUnlock()

	return argCopy
}

// MinimockDetermineActorDone returns true if the count of the DetermineActor invocations corresponds
// the number of defined expectations
func (m *ActorServiceMock) MinimockDetermineActorDone() bool {
	if m.DetermineActorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DetermineActorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DetermineActorMock.invocationsDone()
}

// MinimockDetermineActorInspect logs each unmet expectation
func (m *ActorServiceMock) MinimockDetermineActorInspect() {
	for _, e := range m.DetermineActorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ActorServiceMock.DetermineActor at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDetermineActorCounter := mm_atomic.LoadUint64(&m.afterDetermineActorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DetermineActorMock.defaultExpectation != nil && afterDetermineActorCounter < 1 {
		if m.DetermineActorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ActorServiceMock.DetermineActor at\n%s", m.DetermineActorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ActorServiceMock.DetermineActor at\n%s with params: %#v", m.DetermineActorMock.defaultExpectation.expectationOrigins.origin, *m.DetermineActorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDetermineActor != nil && afterDetermineActorCounter < 1 {
		m.t.Errorf("Expected call to ActorServiceMock.DetermineActor at\n%s", m.funcDetermineActorOrigin)
	}

	if !m.DetermineActorMock.invocationsDone() && afterDetermineActorCounter > 0 {
		m.t.Errorf("Expected %d calls to ActorServiceMock.DetermineActor at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DetermineActorMock.expectedInvocations), m.DetermineActorMock.expectedInvocationsOrigin, afterDetermineActorCounter)
	}
}

type mActorServiceMockFindFreeCourier struct {
	optional           bool
	mock               *ActorServiceMock
	defaultExpectation *ActorServiceMockFindFreeCourierExpectation
	expectations       []*ActorServiceMockFindFreeCourierExpectation

	callArgs []*ActorServiceMockFindFreeCourierParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ActorServiceMockFindFreeCourierExpectation specifies expectation struct of the ActorService.FindFreeCourier
type ActorServiceMockFindFreeCourierExpectation struct {
	mock               *ActorServiceMock
	params             *ActorServiceMockFindFreeCourierParams
	paramPtrs          *ActorServiceMockFindFreeCourierParamPtrs
	expectationOrigins ActorServiceMockFindFreeCourierExpectationOrigins
	results            *ActorServiceMockFindFreeCourierResults
	returnOrigin       string
	Counter            uint64
}

// ActorServiceMockFindFreeCourierParams contains parameters of the ActorService.FindFreeCourier
type ActorServiceMockFindFreeCourierParams struct {
	ctx context.Context
}

// ActorServiceMockFindFreeCourierParamPtrs contains pointers to parameters of the ActorService.FindFreeCourier
type ActorServiceMockFindFreeCourierParamPtrs struct {
	ctx *context.Context
}

// ActorServiceMockFindFreeCourierResults contains results of the ActorService.FindFreeCourier
type ActorServiceMockFindFreeCourierResults struct {
	u1  uint64
	err error
}

// ActorServiceMockFindFreeCourierOrigins contains origins of expectations of the ActorService.FindFreeCourier
type ActorServiceMockFindFreeCourierExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) Optional() *mActorServiceMockFindFreeCourier {
	mmFindFreeCourier.optional = true
	return mmFindFreeCourier
}

// Expect sets up expected params for ActorService.FindFreeCourier
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) Expect(ctx context.Context) *mActorServiceMockFindFreeCourier {
	if mmFindFreeCourier.mock.funcFindFreeCourier != nil {
		mmFindFreeCourier.mock.t.Fatalf("ActorServiceMock.FindFreeCourier mock is already set by Set")
	}

	if mmFindFreeCourier.defaultExpectation == nil {
		mmFindFreeCourier.defaultExpectation = &ActorServiceMockFindFreeCourierExpectation{}
	}

	if mmFindFreeCourier.defaultExpectation.paramPtrs != nil {
		mmFindFreeCourier.mock.t.Fatalf("ActorServiceMock.FindFreeCourier mock is already set by ExpectParams functions")
	}

	mmFindFreeCourier.defaultExpectation.params = &ActorServiceMockFindFreeCourierParams{ctx}
	mmFindFreeCourier.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFindFreeCourier.expectations {
		if minimock.Equal(e.params, mmFindFreeCourier.defaultExpectation.params) {
			mmFindFreeCourier.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindFreeCourier.defaultExpectation.params)
		}
	}

	return mmFindFreeCourier
}

// ExpectCtxParam1 sets up expected param ctx for ActorService.FindFreeCourier
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) ExpectCtxParam1(ctx context.Context) *mActorServiceMockFindFreeCourier {
	if mmFindFreeCourier.mock.funcFindFreeCourier != nil {
		mmFindFreeCourier.mock.t.Fatalf("ActorServiceMock.FindFreeCourier mock is already set by Set")
	}

	if mmFindFreeCourier.defaultExpectation == nil {
		mmFindFreeCourier.defaultExpectation = &ActorServiceMockFindFreeCourierExpectation{}
	}

	if mmFindFreeCourier.defaultExpectation.params != nil {
		mmFindFreeCourier.mock.t.Fatalf("ActorServiceMock.FindFreeCourier mock is already set by Expect")
	}

	if mmFindFreeCourier.defaultExpectation.paramPtrs == nil {
		mmFindFreeCourier.defaultExpectation.paramPtrs = &ActorServiceMockFindFreeCourierParamPtrs{}
	}
	mmFindFreeCourier.defaultExpectation.paramPtrs.ctx = &ctx
	mmFindFreeCourier.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFindFreeCourier
}

// Inspect accepts an inspector function that has same arguments as the ActorService.FindFreeCourier
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) Inspect(f func(ctx context.Context)) *mActorServiceMockFindFreeCourier {
	if mmFindFreeCourier.mock.inspectFuncFindFreeCourier != nil {
		mmFindFreeCourier.mock.t.Fatalf("Inspect function is already set for ActorServiceMock.FindFreeCourier")
	}

	mmFindFreeCourier.mock.inspectFuncFindFreeCourier = f

	return mmFindFreeCourier
}

// Return sets up results that will be returned by ActorService.FindFreeCourier
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) Return(u1 uint64, err error) *ActorServiceMock {
	if mmFindFreeCourier.mock.funcFindFreeCourier != nil {
		mmFindFreeCourier.mock.t.Fatalf("ActorServiceMock.FindFreeCourier mock is already set by Set")
	}

	if mmFindFreeCourier.defaultExpectation == nil {
		mmFindFreeCourier.defaultExpectation = &ActorServiceMockFindFreeCourierExpectation{mock: mmFindFreeCourier.mock}
	}
	mmFindFreeCourier.defaultExpectation.results = &ActorServiceMockFindFreeCourierResults{u1, err}
	mmFindFreeCourier.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFindFreeCourier.mock
}

// Set uses given function f to mock the ActorService.FindFreeCourier method
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) Set(f func(ctx context.Context) (u1 uint64, err error)) *ActorServiceMock {
	if mmFindFreeCourier.defaultExpectation != nil {
		mmFindFreeCourier.mock.t.Fatalf("Default expectation is already set for the ActorService.FindFreeCourier method")
	}

	if len(mmFindFreeCourier.expectations) > 0 {
		mmFindFreeCourier.mock.t.Fatalf("Some expectations are already set for the ActorService.FindFreeCourier method")
	}

	mmFindFreeCourier.mock.funcFindFreeCourier = f
	mmFindFreeCourier.mock.funcFindFreeCourierOrigin = minimock.CallerInfo(1)
	return mmFindFreeCourier.mock
}

// When sets expectation for the ActorService.FindFreeCourier which will trigger the result defined by the following
// Then helper
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) When(ctx context.Context) *ActorServiceMockFindFreeCourierExpectation {
	if mmFindFreeCourier.mock.funcFindFreeCourier != nil {
		mmFindFreeCourier.mock.t.Fatalf("ActorServiceMock.FindFreeCourier mock is already set by Set")
	}

	expectation := &ActorServiceMockFindFreeCourierExpectation{
		mock:               mmFindFreeCourier.mock,
		params:             &ActorServiceMockFindFreeCourierParams{ctx},
		expectationOrigins: ActorServiceMockFindFreeCourierExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFindFreeCourier.expectations = append(mmFindFreeCourier.expectations, expectation)
	return expectation
}

// Then sets up ActorService.FindFreeCourier return parameters for the expectation previously defined by the When method
func (e *ActorServiceMockFindFreeCourierExpectation) Then(u1 uint64, err error) *ActorServiceMock {
	e.results = &ActorServiceMockFindFreeCourierResults{u1, err}
	return e.mock
}

// Times sets number of times ActorService.FindFreeCourier should be invoked
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) Times(n uint64) *mActorServiceMockFindFreeCourier {
	if n == 0 {
		mmFindFreeCourier.mock.t.Fatalf("Times of ActorServiceMock.FindFreeCourier mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFindFreeCourier.expectedInvocations, n)
	mmFindFreeCourier.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFindFreeCourier
}

func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) invocationsDone() bool {
	if len(mmFindFreeCourier.expectations) == 0 && mmFindFreeCourier.defaultExpectation == nil && mmFindFreeCourier.mock.funcFindFreeCourier == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFindFreeCourier.mock.afterFindFreeCourierCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFindFreeCourier.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FindFreeCourier implements mm_services.ActorService
func (mmFindFreeCourier *ActorServiceMock) FindFreeCourier(ctx context.Context) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmFindFreeCourier.beforeFindFreeCourierCounter, 1)
	defer mm_atomic.AddUint64(&mmFindFreeCourier.afterFindFreeCourierCounter, 1)

	mmFindFreeCourier.t.Helper()

	if mmFindFreeCourier.inspectFuncFindFreeCourier != nil {
		mmFindFreeCourier.inspectFuncFindFreeCourier(ctx)
	}

	mm_params := ActorServiceMockFindFreeCourierParams{ctx}

	// Record call args
	mmFindFreeCourier.FindFreeCourierMock.mutex.Lock()
	mmFindFreeCourier.FindFreeCourierMock.callArgs = append(mmFindFreeCourier.FindFreeCourierMock.callArgs, &mm_params)
	mmFindFreeCourier.FindFreeCourierMock.mutex.Unlock()

	for _, e := range mmFindFreeCourier.FindFreeCourierMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmFindFreeCourier.FindFreeCourierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindFreeCourier.FindFreeCourierMock.defaultExpectation.Counter, 1)
		mm_want := mmFindFreeCourier.FindFreeCourierMock.defaultExpectation.params
		mm_want_ptrs := mmFindFreeCourier.FindFreeCourierMock.defaultExpectation.paramPtrs

		mm_got := ActorServiceMockFindFreeCourierParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFindFreeCourier.t.Errorf("ActorServiceMock.FindFreeCourier got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFindFreeCourier.FindFreeCourierMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindFreeCourier.t.Errorf("ActorServiceMock.FindFreeCourier got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFindFreeCourier.FindFreeCourierMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindFreeCourier.FindFreeCourierMock.defaultExpectation.results
		if mm_results == nil {
			mmFindFreeCourier.t.Fatal("No results are set for the ActorServiceMock.FindFreeCourier")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmFindFreeCourier.funcFindFreeCourier != nil {
		return mmFindFreeCourier.funcFindFreeCourier(ctx)
	}
	mmFindFreeCourier.t.Fatalf("Unexpected call to ActorServiceMock.FindFreeCourier. %v", ctx)
	return
}

// FindFreeCourierAfterCounter returns a count of finished ActorServiceMock.FindFreeCourier invocations
func (mmFindFreeCourier *ActorServiceMock) FindFreeCourierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindFreeCourier.afterFindFreeCourierCounter)
}

// FindFreeCourierBeforeCounter returns a count of ActorServiceMock.FindFreeCourier invocations
func (mmFindFreeCourier *ActorServiceMock) FindFreeCourierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindFreeCourier.beforeFindFreeCourierCounter)
}

// Calls returns a list of arguments used in each call to ActorServiceMock.FindFreeCourier.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindFreeCourier *mActorServiceMockFindFreeCourier) Calls() []*ActorServiceMockFindFreeCourierParams {
	mmFindFreeCourier.mutex.RLock()

	argCopy := make([]*ActorServiceMockFindFreeCourierParams, len(mmFindFreeCourier.callArgs))
	copy(argCopy, mmFindFreeCourier.callArgs)

	mmFindFreeCourier.mutex.RUnlock()

	return argCopy
}

// MinimockFindFreeCourierDone returns true if the count of the FindFreeCourier invocations corresponds
// the number of defined expectations
func (m *ActorServiceMock) MinimockFindFreeCourierDone() bool {
	if m.FindFreeCourierMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FindFreeCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FindFreeCourierMock.invocationsDone()
}

// MinimockFindFreeCourierInspect logs each unmet expectation
func (m *ActorServiceMock) MinimockFindFreeCourierInspect() {
	for _, e := range m.FindFreeCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ActorServiceMock.FindFreeCourier at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFindFreeCourierCounter := mm_atomic.LoadUint64(&m.afterFindFreeCourierCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FindFreeCourierMock.defaultExpectation != nil && afterFindFreeCourierCounter < 1 {
		if m.FindFreeCourierMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ActorServiceMock.FindFreeCourier at\n%s", m.FindFreeCourierMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ActorServiceMock.FindFreeCourier at\n%s with params: %#v", m.FindFreeCourierMock.defaultExpectation.expectationOrigins.origin, *m.FindFreeCourierMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindFreeCourier != nil && afterFindFreeCourierCounter < 1 {
		m.t.Errorf("Expected call to ActorServiceMock.FindFreeCourier at\n%s", m.funcFindFreeCourierOrigin)
	}

	if !m.FindFreeCourierMock.invocationsDone() && afterFindFreeCourierCounter > 0 {
		m.t.Errorf("Expected %d calls to ActorServiceMock.FindFreeCourier at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FindFreeCourierMock.expectedInvocations), m.FindFreeCourierMock.expectedInvocationsOrigin, afterFindFreeCourierCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ActorServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDetermineActorInspect()

			m.MinimockFindFreeCourierInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ActorServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ActorServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDetermineActorDone() &&
		m.MinimockFindFreeCourierDone()
}
