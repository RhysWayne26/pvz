// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

import (
	"context"
	"pvz-cli/internal/models"
	"pvz-cli/internal/usecases/requests"
	"pvz-cli/internal/usecases/services/shared"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderServiceMock implements mm_services.OrderService
type OrderServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptOrder          func(ctx context.Context, req requests.AcceptOrderRequest) (o1 models.Order, err error)
	funcAcceptOrderOrigin    string
	inspectFuncAcceptOrder   func(ctx context.Context, req requests.AcceptOrderRequest)
	afterAcceptOrderCounter  uint64
	beforeAcceptOrderCounter uint64
	AcceptOrderMock          mOrderServiceMockAcceptOrder

	funcCreateClientReturns          func(ctx context.Context, req requests.ClientReturnsRequest) (ba1 []shared.BatchEntryProcessedResult, err error)
	funcCreateClientReturnsOrigin    string
	inspectFuncCreateClientReturns   func(ctx context.Context, req requests.ClientReturnsRequest)
	afterCreateClientReturnsCounter  uint64
	beforeCreateClientReturnsCounter uint64
	CreateClientReturnsMock          mOrderServiceMockCreateClientReturns

	funcImportOrders          func(ctx context.Context, req requests.ImportOrdersRequest) (ba1 []shared.BatchEntryProcessedResult, err error)
	funcImportOrdersOrigin    string
	inspectFuncImportOrders   func(ctx context.Context, req requests.ImportOrdersRequest)
	afterImportOrdersCounter  uint64
	beforeImportOrdersCounter uint64
	ImportOrdersMock          mOrderServiceMockImportOrders

	funcIssueOrders          func(ctx context.Context, req requests.IssueOrdersRequest) (ba1 []shared.BatchEntryProcessedResult, err error)
	funcIssueOrdersOrigin    string
	inspectFuncIssueOrders   func(ctx context.Context, req requests.IssueOrdersRequest)
	afterIssueOrdersCounter  uint64
	beforeIssueOrdersCounter uint64
	IssueOrdersMock          mOrderServiceMockIssueOrders

	funcListOrders          func(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, u1 uint64, i1 int, err error)
	funcListOrdersOrigin    string
	inspectFuncListOrders   func(ctx context.Context, filter requests.OrdersFilterRequest)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mOrderServiceMockListOrders

	funcListReturns          func(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, err error)
	funcListReturnsOrigin    string
	inspectFuncListReturns   func(ctx context.Context, filter requests.OrdersFilterRequest)
	afterListReturnsCounter  uint64
	beforeListReturnsCounter uint64
	ListReturnsMock          mOrderServiceMockListReturns

	funcReturnToCourier          func(ctx context.Context, req requests.ReturnOrderRequest) (err error)
	funcReturnToCourierOrigin    string
	inspectFuncReturnToCourier   func(ctx context.Context, req requests.ReturnOrderRequest)
	afterReturnToCourierCounter  uint64
	beforeReturnToCourierCounter uint64
	ReturnToCourierMock          mOrderServiceMockReturnToCourier
}

// NewOrderServiceMock returns a mock for mm_services.OrderService
func NewOrderServiceMock(t minimock.Tester) *OrderServiceMock {
	m := &OrderServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptOrderMock = mOrderServiceMockAcceptOrder{mock: m}
	m.AcceptOrderMock.callArgs = []*OrderServiceMockAcceptOrderParams{}

	m.CreateClientReturnsMock = mOrderServiceMockCreateClientReturns{mock: m}
	m.CreateClientReturnsMock.callArgs = []*OrderServiceMockCreateClientReturnsParams{}

	m.ImportOrdersMock = mOrderServiceMockImportOrders{mock: m}
	m.ImportOrdersMock.callArgs = []*OrderServiceMockImportOrdersParams{}

	m.IssueOrdersMock = mOrderServiceMockIssueOrders{mock: m}
	m.IssueOrdersMock.callArgs = []*OrderServiceMockIssueOrdersParams{}

	m.ListOrdersMock = mOrderServiceMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*OrderServiceMockListOrdersParams{}

	m.ListReturnsMock = mOrderServiceMockListReturns{mock: m}
	m.ListReturnsMock.callArgs = []*OrderServiceMockListReturnsParams{}

	m.ReturnToCourierMock = mOrderServiceMockReturnToCourier{mock: m}
	m.ReturnToCourierMock.callArgs = []*OrderServiceMockReturnToCourierParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderServiceMockAcceptOrder struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockAcceptOrderExpectation
	expectations       []*OrderServiceMockAcceptOrderExpectation

	callArgs []*OrderServiceMockAcceptOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockAcceptOrderExpectation specifies expectation struct of the OrderService.AcceptOrder
type OrderServiceMockAcceptOrderExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockAcceptOrderParams
	paramPtrs          *OrderServiceMockAcceptOrderParamPtrs
	expectationOrigins OrderServiceMockAcceptOrderExpectationOrigins
	results            *OrderServiceMockAcceptOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockAcceptOrderParams contains parameters of the OrderService.AcceptOrder
type OrderServiceMockAcceptOrderParams struct {
	ctx context.Context
	req requests.AcceptOrderRequest
}

// OrderServiceMockAcceptOrderParamPtrs contains pointers to parameters of the OrderService.AcceptOrder
type OrderServiceMockAcceptOrderParamPtrs struct {
	ctx *context.Context
	req *requests.AcceptOrderRequest
}

// OrderServiceMockAcceptOrderResults contains results of the OrderService.AcceptOrder
type OrderServiceMockAcceptOrderResults struct {
	o1  models.Order
	err error
}

// OrderServiceMockAcceptOrderOrigins contains origins of expectations of the OrderService.AcceptOrder
type OrderServiceMockAcceptOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) Optional() *mOrderServiceMockAcceptOrder {
	mmAcceptOrder.optional = true
	return mmAcceptOrder
}

// Expect sets up expected params for OrderService.AcceptOrder
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) Expect(ctx context.Context, req requests.AcceptOrderRequest) *mOrderServiceMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &OrderServiceMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by ExpectParams functions")
	}

	mmAcceptOrder.defaultExpectation.params = &OrderServiceMockAcceptOrderParams{ctx, req}
	mmAcceptOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptOrder.expectations {
		if minimock.Equal(e.params, mmAcceptOrder.defaultExpectation.params) {
			mmAcceptOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptOrder.defaultExpectation.params)
		}
	}

	return mmAcceptOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.AcceptOrder
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &OrderServiceMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.params != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by Expect")
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs == nil {
		mmAcceptOrder.defaultExpectation.paramPtrs = &OrderServiceMockAcceptOrderParamPtrs{}
	}
	mmAcceptOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmAcceptOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAcceptOrder
}

// ExpectReqParam2 sets up expected param req for OrderService.AcceptOrder
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) ExpectReqParam2(req requests.AcceptOrderRequest) *mOrderServiceMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &OrderServiceMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.params != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by Expect")
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs == nil {
		mmAcceptOrder.defaultExpectation.paramPtrs = &OrderServiceMockAcceptOrderParamPtrs{}
	}
	mmAcceptOrder.defaultExpectation.paramPtrs.req = &req
	mmAcceptOrder.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmAcceptOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderService.AcceptOrder
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) Inspect(f func(ctx context.Context, req requests.AcceptOrderRequest)) *mOrderServiceMockAcceptOrder {
	if mmAcceptOrder.mock.inspectFuncAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.AcceptOrder")
	}

	mmAcceptOrder.mock.inspectFuncAcceptOrder = f

	return mmAcceptOrder
}

// Return sets up results that will be returned by OrderService.AcceptOrder
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) Return(o1 models.Order, err error) *OrderServiceMock {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &OrderServiceMockAcceptOrderExpectation{mock: mmAcceptOrder.mock}
	}
	mmAcceptOrder.defaultExpectation.results = &OrderServiceMockAcceptOrderResults{o1, err}
	mmAcceptOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder.mock
}

// Set uses given function f to mock the OrderService.AcceptOrder method
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) Set(f func(ctx context.Context, req requests.AcceptOrderRequest) (o1 models.Order, err error)) *OrderServiceMock {
	if mmAcceptOrder.defaultExpectation != nil {
		mmAcceptOrder.mock.t.Fatalf("Default expectation is already set for the OrderService.AcceptOrder method")
	}

	if len(mmAcceptOrder.expectations) > 0 {
		mmAcceptOrder.mock.t.Fatalf("Some expectations are already set for the OrderService.AcceptOrder method")
	}

	mmAcceptOrder.mock.funcAcceptOrder = f
	mmAcceptOrder.mock.funcAcceptOrderOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder.mock
}

// When sets expectation for the OrderService.AcceptOrder which will trigger the result defined by the following
// Then helper
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) When(ctx context.Context, req requests.AcceptOrderRequest) *OrderServiceMockAcceptOrderExpectation {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("OrderServiceMock.AcceptOrder mock is already set by Set")
	}

	expectation := &OrderServiceMockAcceptOrderExpectation{
		mock:               mmAcceptOrder.mock,
		params:             &OrderServiceMockAcceptOrderParams{ctx, req},
		expectationOrigins: OrderServiceMockAcceptOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptOrder.expectations = append(mmAcceptOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderService.AcceptOrder return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockAcceptOrderExpectation) Then(o1 models.Order, err error) *OrderServiceMock {
	e.results = &OrderServiceMockAcceptOrderResults{o1, err}
	return e.mock
}

// Times sets number of times OrderService.AcceptOrder should be invoked
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) Times(n uint64) *mOrderServiceMockAcceptOrder {
	if n == 0 {
		mmAcceptOrder.mock.t.Fatalf("Times of OrderServiceMock.AcceptOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptOrder.expectedInvocations, n)
	mmAcceptOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder
}

func (mmAcceptOrder *mOrderServiceMockAcceptOrder) invocationsDone() bool {
	if len(mmAcceptOrder.expectations) == 0 && mmAcceptOrder.defaultExpectation == nil && mmAcceptOrder.mock.funcAcceptOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptOrder.mock.afterAcceptOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptOrder implements mm_services.OrderService
func (mmAcceptOrder *OrderServiceMock) AcceptOrder(ctx context.Context, req requests.AcceptOrderRequest) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmAcceptOrder.beforeAcceptOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptOrder.afterAcceptOrderCounter, 1)

	mmAcceptOrder.t.Helper()

	if mmAcceptOrder.inspectFuncAcceptOrder != nil {
		mmAcceptOrder.inspectFuncAcceptOrder(ctx, req)
	}

	mm_params := OrderServiceMockAcceptOrderParams{ctx, req}

	// Record call args
	mmAcceptOrder.AcceptOrderMock.mutex.Lock()
	mmAcceptOrder.AcceptOrderMock.callArgs = append(mmAcceptOrder.AcceptOrderMock.callArgs, &mm_params)
	mmAcceptOrder.AcceptOrderMock.mutex.Unlock()

	for _, e := range mmAcceptOrder.AcceptOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmAcceptOrder.AcceptOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptOrder.AcceptOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptOrder.AcceptOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptOrder.AcceptOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockAcceptOrderParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAcceptOrder.t.Errorf("OrderServiceMock.AcceptOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmAcceptOrder.t.Errorf("OrderServiceMock.AcceptOrder got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptOrder.t.Errorf("OrderServiceMock.AcceptOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptOrder.AcceptOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptOrder.t.Fatal("No results are set for the OrderServiceMock.AcceptOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmAcceptOrder.funcAcceptOrder != nil {
		return mmAcceptOrder.funcAcceptOrder(ctx, req)
	}
	mmAcceptOrder.t.Fatalf("Unexpected call to OrderServiceMock.AcceptOrder. %v %v", ctx, req)
	return
}

// AcceptOrderAfterCounter returns a count of finished OrderServiceMock.AcceptOrder invocations
func (mmAcceptOrder *OrderServiceMock) AcceptOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrder.afterAcceptOrderCounter)
}

// AcceptOrderBeforeCounter returns a count of OrderServiceMock.AcceptOrder invocations
func (mmAcceptOrder *OrderServiceMock) AcceptOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrder.beforeAcceptOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.AcceptOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptOrder *mOrderServiceMockAcceptOrder) Calls() []*OrderServiceMockAcceptOrderParams {
	mmAcceptOrder.mutex.RLock()

	argCopy := make([]*OrderServiceMockAcceptOrderParams, len(mmAcceptOrder.callArgs))
	copy(argCopy, mmAcceptOrder.callArgs)

	mmAcceptOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptOrderDone returns true if the count of the AcceptOrder invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockAcceptOrderDone() bool {
	if m.AcceptOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptOrderMock.invocationsDone()
}

// MinimockAcceptOrderInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockAcceptOrderInspect() {
	for _, e := range m.AcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.AcceptOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptOrderCounter := mm_atomic.LoadUint64(&m.afterAcceptOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptOrderMock.defaultExpectation != nil && afterAcceptOrderCounter < 1 {
		if m.AcceptOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.AcceptOrder at\n%s", m.AcceptOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.AcceptOrder at\n%s with params: %#v", m.AcceptOrderMock.defaultExpectation.expectationOrigins.origin, *m.AcceptOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptOrder != nil && afterAcceptOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.AcceptOrder at\n%s", m.funcAcceptOrderOrigin)
	}

	if !m.AcceptOrderMock.invocationsDone() && afterAcceptOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.AcceptOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptOrderMock.expectedInvocations), m.AcceptOrderMock.expectedInvocationsOrigin, afterAcceptOrderCounter)
	}
}

type mOrderServiceMockCreateClientReturns struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockCreateClientReturnsExpectation
	expectations       []*OrderServiceMockCreateClientReturnsExpectation

	callArgs []*OrderServiceMockCreateClientReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockCreateClientReturnsExpectation specifies expectation struct of the OrderService.CreateClientReturns
type OrderServiceMockCreateClientReturnsExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockCreateClientReturnsParams
	paramPtrs          *OrderServiceMockCreateClientReturnsParamPtrs
	expectationOrigins OrderServiceMockCreateClientReturnsExpectationOrigins
	results            *OrderServiceMockCreateClientReturnsResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockCreateClientReturnsParams contains parameters of the OrderService.CreateClientReturns
type OrderServiceMockCreateClientReturnsParams struct {
	ctx context.Context
	req requests.ClientReturnsRequest
}

// OrderServiceMockCreateClientReturnsParamPtrs contains pointers to parameters of the OrderService.CreateClientReturns
type OrderServiceMockCreateClientReturnsParamPtrs struct {
	ctx *context.Context
	req *requests.ClientReturnsRequest
}

// OrderServiceMockCreateClientReturnsResults contains results of the OrderService.CreateClientReturns
type OrderServiceMockCreateClientReturnsResults struct {
	ba1 []shared.BatchEntryProcessedResult
	err error
}

// OrderServiceMockCreateClientReturnsOrigins contains origins of expectations of the OrderService.CreateClientReturns
type OrderServiceMockCreateClientReturnsExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) Optional() *mOrderServiceMockCreateClientReturns {
	mmCreateClientReturns.optional = true
	return mmCreateClientReturns
}

// Expect sets up expected params for OrderService.CreateClientReturns
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) Expect(ctx context.Context, req requests.ClientReturnsRequest) *mOrderServiceMockCreateClientReturns {
	if mmCreateClientReturns.mock.funcCreateClientReturns != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by Set")
	}

	if mmCreateClientReturns.defaultExpectation == nil {
		mmCreateClientReturns.defaultExpectation = &OrderServiceMockCreateClientReturnsExpectation{}
	}

	if mmCreateClientReturns.defaultExpectation.paramPtrs != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by ExpectParams functions")
	}

	mmCreateClientReturns.defaultExpectation.params = &OrderServiceMockCreateClientReturnsParams{ctx, req}
	mmCreateClientReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateClientReturns.expectations {
		if minimock.Equal(e.params, mmCreateClientReturns.defaultExpectation.params) {
			mmCreateClientReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateClientReturns.defaultExpectation.params)
		}
	}

	return mmCreateClientReturns
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.CreateClientReturns
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockCreateClientReturns {
	if mmCreateClientReturns.mock.funcCreateClientReturns != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by Set")
	}

	if mmCreateClientReturns.defaultExpectation == nil {
		mmCreateClientReturns.defaultExpectation = &OrderServiceMockCreateClientReturnsExpectation{}
	}

	if mmCreateClientReturns.defaultExpectation.params != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by Expect")
	}

	if mmCreateClientReturns.defaultExpectation.paramPtrs == nil {
		mmCreateClientReturns.defaultExpectation.paramPtrs = &OrderServiceMockCreateClientReturnsParamPtrs{}
	}
	mmCreateClientReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateClientReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateClientReturns
}

// ExpectReqParam2 sets up expected param req for OrderService.CreateClientReturns
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) ExpectReqParam2(req requests.ClientReturnsRequest) *mOrderServiceMockCreateClientReturns {
	if mmCreateClientReturns.mock.funcCreateClientReturns != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by Set")
	}

	if mmCreateClientReturns.defaultExpectation == nil {
		mmCreateClientReturns.defaultExpectation = &OrderServiceMockCreateClientReturnsExpectation{}
	}

	if mmCreateClientReturns.defaultExpectation.params != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by Expect")
	}

	if mmCreateClientReturns.defaultExpectation.paramPtrs == nil {
		mmCreateClientReturns.defaultExpectation.paramPtrs = &OrderServiceMockCreateClientReturnsParamPtrs{}
	}
	mmCreateClientReturns.defaultExpectation.paramPtrs.req = &req
	mmCreateClientReturns.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmCreateClientReturns
}

// Inspect accepts an inspector function that has same arguments as the OrderService.CreateClientReturns
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) Inspect(f func(ctx context.Context, req requests.ClientReturnsRequest)) *mOrderServiceMockCreateClientReturns {
	if mmCreateClientReturns.mock.inspectFuncCreateClientReturns != nil {
		mmCreateClientReturns.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.CreateClientReturns")
	}

	mmCreateClientReturns.mock.inspectFuncCreateClientReturns = f

	return mmCreateClientReturns
}

// Return sets up results that will be returned by OrderService.CreateClientReturns
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) Return(ba1 []shared.BatchEntryProcessedResult, err error) *OrderServiceMock {
	if mmCreateClientReturns.mock.funcCreateClientReturns != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by Set")
	}

	if mmCreateClientReturns.defaultExpectation == nil {
		mmCreateClientReturns.defaultExpectation = &OrderServiceMockCreateClientReturnsExpectation{mock: mmCreateClientReturns.mock}
	}
	mmCreateClientReturns.defaultExpectation.results = &OrderServiceMockCreateClientReturnsResults{ba1, err}
	mmCreateClientReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateClientReturns.mock
}

// Set uses given function f to mock the OrderService.CreateClientReturns method
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) Set(f func(ctx context.Context, req requests.ClientReturnsRequest) (ba1 []shared.BatchEntryProcessedResult, err error)) *OrderServiceMock {
	if mmCreateClientReturns.defaultExpectation != nil {
		mmCreateClientReturns.mock.t.Fatalf("Default expectation is already set for the OrderService.CreateClientReturns method")
	}

	if len(mmCreateClientReturns.expectations) > 0 {
		mmCreateClientReturns.mock.t.Fatalf("Some expectations are already set for the OrderService.CreateClientReturns method")
	}

	mmCreateClientReturns.mock.funcCreateClientReturns = f
	mmCreateClientReturns.mock.funcCreateClientReturnsOrigin = minimock.CallerInfo(1)
	return mmCreateClientReturns.mock
}

// When sets expectation for the OrderService.CreateClientReturns which will trigger the result defined by the following
// Then helper
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) When(ctx context.Context, req requests.ClientReturnsRequest) *OrderServiceMockCreateClientReturnsExpectation {
	if mmCreateClientReturns.mock.funcCreateClientReturns != nil {
		mmCreateClientReturns.mock.t.Fatalf("OrderServiceMock.CreateClientReturns mock is already set by Set")
	}

	expectation := &OrderServiceMockCreateClientReturnsExpectation{
		mock:               mmCreateClientReturns.mock,
		params:             &OrderServiceMockCreateClientReturnsParams{ctx, req},
		expectationOrigins: OrderServiceMockCreateClientReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateClientReturns.expectations = append(mmCreateClientReturns.expectations, expectation)
	return expectation
}

// Then sets up OrderService.CreateClientReturns return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockCreateClientReturnsExpectation) Then(ba1 []shared.BatchEntryProcessedResult, err error) *OrderServiceMock {
	e.results = &OrderServiceMockCreateClientReturnsResults{ba1, err}
	return e.mock
}

// Times sets number of times OrderService.CreateClientReturns should be invoked
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) Times(n uint64) *mOrderServiceMockCreateClientReturns {
	if n == 0 {
		mmCreateClientReturns.mock.t.Fatalf("Times of OrderServiceMock.CreateClientReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateClientReturns.expectedInvocations, n)
	mmCreateClientReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateClientReturns
}

func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) invocationsDone() bool {
	if len(mmCreateClientReturns.expectations) == 0 && mmCreateClientReturns.defaultExpectation == nil && mmCreateClientReturns.mock.funcCreateClientReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateClientReturns.mock.afterCreateClientReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateClientReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateClientReturns implements mm_services.OrderService
func (mmCreateClientReturns *OrderServiceMock) CreateClientReturns(ctx context.Context, req requests.ClientReturnsRequest) (ba1 []shared.BatchEntryProcessedResult, err error) {
	mm_atomic.AddUint64(&mmCreateClientReturns.beforeCreateClientReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateClientReturns.afterCreateClientReturnsCounter, 1)

	mmCreateClientReturns.t.Helper()

	if mmCreateClientReturns.inspectFuncCreateClientReturns != nil {
		mmCreateClientReturns.inspectFuncCreateClientReturns(ctx, req)
	}

	mm_params := OrderServiceMockCreateClientReturnsParams{ctx, req}

	// Record call args
	mmCreateClientReturns.CreateClientReturnsMock.mutex.Lock()
	mmCreateClientReturns.CreateClientReturnsMock.callArgs = append(mmCreateClientReturns.CreateClientReturnsMock.callArgs, &mm_params)
	mmCreateClientReturns.CreateClientReturnsMock.mutex.Unlock()

	for _, e := range mmCreateClientReturns.CreateClientReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockCreateClientReturnsParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateClientReturns.t.Errorf("OrderServiceMock.CreateClientReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmCreateClientReturns.t.Errorf("OrderServiceMock.CreateClientReturns got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateClientReturns.t.Errorf("OrderServiceMock.CreateClientReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateClientReturns.CreateClientReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateClientReturns.t.Fatal("No results are set for the OrderServiceMock.CreateClientReturns")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmCreateClientReturns.funcCreateClientReturns != nil {
		return mmCreateClientReturns.funcCreateClientReturns(ctx, req)
	}
	mmCreateClientReturns.t.Fatalf("Unexpected call to OrderServiceMock.CreateClientReturns. %v %v", ctx, req)
	return
}

// CreateClientReturnsAfterCounter returns a count of finished OrderServiceMock.CreateClientReturns invocations
func (mmCreateClientReturns *OrderServiceMock) CreateClientReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClientReturns.afterCreateClientReturnsCounter)
}

// CreateClientReturnsBeforeCounter returns a count of OrderServiceMock.CreateClientReturns invocations
func (mmCreateClientReturns *OrderServiceMock) CreateClientReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClientReturns.beforeCreateClientReturnsCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.CreateClientReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateClientReturns *mOrderServiceMockCreateClientReturns) Calls() []*OrderServiceMockCreateClientReturnsParams {
	mmCreateClientReturns.mutex.RLock()

	argCopy := make([]*OrderServiceMockCreateClientReturnsParams, len(mmCreateClientReturns.callArgs))
	copy(argCopy, mmCreateClientReturns.callArgs)

	mmCreateClientReturns.mutex.RUnlock()

	return argCopy
}

// MinimockCreateClientReturnsDone returns true if the count of the CreateClientReturns invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockCreateClientReturnsDone() bool {
	if m.CreateClientReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateClientReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateClientReturnsMock.invocationsDone()
}

// MinimockCreateClientReturnsInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockCreateClientReturnsInspect() {
	for _, e := range m.CreateClientReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.CreateClientReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateClientReturnsCounter := mm_atomic.LoadUint64(&m.afterCreateClientReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClientReturnsMock.defaultExpectation != nil && afterCreateClientReturnsCounter < 1 {
		if m.CreateClientReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.CreateClientReturns at\n%s", m.CreateClientReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.CreateClientReturns at\n%s with params: %#v", m.CreateClientReturnsMock.defaultExpectation.expectationOrigins.origin, *m.CreateClientReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClientReturns != nil && afterCreateClientReturnsCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.CreateClientReturns at\n%s", m.funcCreateClientReturnsOrigin)
	}

	if !m.CreateClientReturnsMock.invocationsDone() && afterCreateClientReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.CreateClientReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateClientReturnsMock.expectedInvocations), m.CreateClientReturnsMock.expectedInvocationsOrigin, afterCreateClientReturnsCounter)
	}
}

type mOrderServiceMockImportOrders struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockImportOrdersExpectation
	expectations       []*OrderServiceMockImportOrdersExpectation

	callArgs []*OrderServiceMockImportOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockImportOrdersExpectation specifies expectation struct of the OrderService.ImportOrders
type OrderServiceMockImportOrdersExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockImportOrdersParams
	paramPtrs          *OrderServiceMockImportOrdersParamPtrs
	expectationOrigins OrderServiceMockImportOrdersExpectationOrigins
	results            *OrderServiceMockImportOrdersResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockImportOrdersParams contains parameters of the OrderService.ImportOrders
type OrderServiceMockImportOrdersParams struct {
	ctx context.Context
	req requests.ImportOrdersRequest
}

// OrderServiceMockImportOrdersParamPtrs contains pointers to parameters of the OrderService.ImportOrders
type OrderServiceMockImportOrdersParamPtrs struct {
	ctx *context.Context
	req *requests.ImportOrdersRequest
}

// OrderServiceMockImportOrdersResults contains results of the OrderService.ImportOrders
type OrderServiceMockImportOrdersResults struct {
	ba1 []shared.BatchEntryProcessedResult
	err error
}

// OrderServiceMockImportOrdersOrigins contains origins of expectations of the OrderService.ImportOrders
type OrderServiceMockImportOrdersExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImportOrders *mOrderServiceMockImportOrders) Optional() *mOrderServiceMockImportOrders {
	mmImportOrders.optional = true
	return mmImportOrders
}

// Expect sets up expected params for OrderService.ImportOrders
func (mmImportOrders *mOrderServiceMockImportOrders) Expect(ctx context.Context, req requests.ImportOrdersRequest) *mOrderServiceMockImportOrders {
	if mmImportOrders.mock.funcImportOrders != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by Set")
	}

	if mmImportOrders.defaultExpectation == nil {
		mmImportOrders.defaultExpectation = &OrderServiceMockImportOrdersExpectation{}
	}

	if mmImportOrders.defaultExpectation.paramPtrs != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by ExpectParams functions")
	}

	mmImportOrders.defaultExpectation.params = &OrderServiceMockImportOrdersParams{ctx, req}
	mmImportOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImportOrders.expectations {
		if minimock.Equal(e.params, mmImportOrders.defaultExpectation.params) {
			mmImportOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImportOrders.defaultExpectation.params)
		}
	}

	return mmImportOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.ImportOrders
func (mmImportOrders *mOrderServiceMockImportOrders) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockImportOrders {
	if mmImportOrders.mock.funcImportOrders != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by Set")
	}

	if mmImportOrders.defaultExpectation == nil {
		mmImportOrders.defaultExpectation = &OrderServiceMockImportOrdersExpectation{}
	}

	if mmImportOrders.defaultExpectation.params != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by Expect")
	}

	if mmImportOrders.defaultExpectation.paramPtrs == nil {
		mmImportOrders.defaultExpectation.paramPtrs = &OrderServiceMockImportOrdersParamPtrs{}
	}
	mmImportOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmImportOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImportOrders
}

// ExpectReqParam2 sets up expected param req for OrderService.ImportOrders
func (mmImportOrders *mOrderServiceMockImportOrders) ExpectReqParam2(req requests.ImportOrdersRequest) *mOrderServiceMockImportOrders {
	if mmImportOrders.mock.funcImportOrders != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by Set")
	}

	if mmImportOrders.defaultExpectation == nil {
		mmImportOrders.defaultExpectation = &OrderServiceMockImportOrdersExpectation{}
	}

	if mmImportOrders.defaultExpectation.params != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by Expect")
	}

	if mmImportOrders.defaultExpectation.paramPtrs == nil {
		mmImportOrders.defaultExpectation.paramPtrs = &OrderServiceMockImportOrdersParamPtrs{}
	}
	mmImportOrders.defaultExpectation.paramPtrs.req = &req
	mmImportOrders.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmImportOrders
}

// Inspect accepts an inspector function that has same arguments as the OrderService.ImportOrders
func (mmImportOrders *mOrderServiceMockImportOrders) Inspect(f func(ctx context.Context, req requests.ImportOrdersRequest)) *mOrderServiceMockImportOrders {
	if mmImportOrders.mock.inspectFuncImportOrders != nil {
		mmImportOrders.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.ImportOrders")
	}

	mmImportOrders.mock.inspectFuncImportOrders = f

	return mmImportOrders
}

// Return sets up results that will be returned by OrderService.ImportOrders
func (mmImportOrders *mOrderServiceMockImportOrders) Return(ba1 []shared.BatchEntryProcessedResult, err error) *OrderServiceMock {
	if mmImportOrders.mock.funcImportOrders != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by Set")
	}

	if mmImportOrders.defaultExpectation == nil {
		mmImportOrders.defaultExpectation = &OrderServiceMockImportOrdersExpectation{mock: mmImportOrders.mock}
	}
	mmImportOrders.defaultExpectation.results = &OrderServiceMockImportOrdersResults{ba1, err}
	mmImportOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImportOrders.mock
}

// Set uses given function f to mock the OrderService.ImportOrders method
func (mmImportOrders *mOrderServiceMockImportOrders) Set(f func(ctx context.Context, req requests.ImportOrdersRequest) (ba1 []shared.BatchEntryProcessedResult, err error)) *OrderServiceMock {
	if mmImportOrders.defaultExpectation != nil {
		mmImportOrders.mock.t.Fatalf("Default expectation is already set for the OrderService.ImportOrders method")
	}

	if len(mmImportOrders.expectations) > 0 {
		mmImportOrders.mock.t.Fatalf("Some expectations are already set for the OrderService.ImportOrders method")
	}

	mmImportOrders.mock.funcImportOrders = f
	mmImportOrders.mock.funcImportOrdersOrigin = minimock.CallerInfo(1)
	return mmImportOrders.mock
}

// When sets expectation for the OrderService.ImportOrders which will trigger the result defined by the following
// Then helper
func (mmImportOrders *mOrderServiceMockImportOrders) When(ctx context.Context, req requests.ImportOrdersRequest) *OrderServiceMockImportOrdersExpectation {
	if mmImportOrders.mock.funcImportOrders != nil {
		mmImportOrders.mock.t.Fatalf("OrderServiceMock.ImportOrders mock is already set by Set")
	}

	expectation := &OrderServiceMockImportOrdersExpectation{
		mock:               mmImportOrders.mock,
		params:             &OrderServiceMockImportOrdersParams{ctx, req},
		expectationOrigins: OrderServiceMockImportOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImportOrders.expectations = append(mmImportOrders.expectations, expectation)
	return expectation
}

// Then sets up OrderService.ImportOrders return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockImportOrdersExpectation) Then(ba1 []shared.BatchEntryProcessedResult, err error) *OrderServiceMock {
	e.results = &OrderServiceMockImportOrdersResults{ba1, err}
	return e.mock
}

// Times sets number of times OrderService.ImportOrders should be invoked
func (mmImportOrders *mOrderServiceMockImportOrders) Times(n uint64) *mOrderServiceMockImportOrders {
	if n == 0 {
		mmImportOrders.mock.t.Fatalf("Times of OrderServiceMock.ImportOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImportOrders.expectedInvocations, n)
	mmImportOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImportOrders
}

func (mmImportOrders *mOrderServiceMockImportOrders) invocationsDone() bool {
	if len(mmImportOrders.expectations) == 0 && mmImportOrders.defaultExpectation == nil && mmImportOrders.mock.funcImportOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImportOrders.mock.afterImportOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImportOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ImportOrders implements mm_services.OrderService
func (mmImportOrders *OrderServiceMock) ImportOrders(ctx context.Context, req requests.ImportOrdersRequest) (ba1 []shared.BatchEntryProcessedResult, err error) {
	mm_atomic.AddUint64(&mmImportOrders.beforeImportOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmImportOrders.afterImportOrdersCounter, 1)

	mmImportOrders.t.Helper()

	if mmImportOrders.inspectFuncImportOrders != nil {
		mmImportOrders.inspectFuncImportOrders(ctx, req)
	}

	mm_params := OrderServiceMockImportOrdersParams{ctx, req}

	// Record call args
	mmImportOrders.ImportOrdersMock.mutex.Lock()
	mmImportOrders.ImportOrdersMock.callArgs = append(mmImportOrders.ImportOrdersMock.callArgs, &mm_params)
	mmImportOrders.ImportOrdersMock.mutex.Unlock()

	for _, e := range mmImportOrders.ImportOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmImportOrders.ImportOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImportOrders.ImportOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmImportOrders.ImportOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmImportOrders.ImportOrdersMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockImportOrdersParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImportOrders.t.Errorf("OrderServiceMock.ImportOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImportOrders.ImportOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmImportOrders.t.Errorf("OrderServiceMock.ImportOrders got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImportOrders.ImportOrdersMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImportOrders.t.Errorf("OrderServiceMock.ImportOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImportOrders.ImportOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImportOrders.ImportOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmImportOrders.t.Fatal("No results are set for the OrderServiceMock.ImportOrders")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmImportOrders.funcImportOrders != nil {
		return mmImportOrders.funcImportOrders(ctx, req)
	}
	mmImportOrders.t.Fatalf("Unexpected call to OrderServiceMock.ImportOrders. %v %v", ctx, req)
	return
}

// ImportOrdersAfterCounter returns a count of finished OrderServiceMock.ImportOrders invocations
func (mmImportOrders *OrderServiceMock) ImportOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportOrders.afterImportOrdersCounter)
}

// ImportOrdersBeforeCounter returns a count of OrderServiceMock.ImportOrders invocations
func (mmImportOrders *OrderServiceMock) ImportOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImportOrders.beforeImportOrdersCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.ImportOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImportOrders *mOrderServiceMockImportOrders) Calls() []*OrderServiceMockImportOrdersParams {
	mmImportOrders.mutex.RLock()

	argCopy := make([]*OrderServiceMockImportOrdersParams, len(mmImportOrders.callArgs))
	copy(argCopy, mmImportOrders.callArgs)

	mmImportOrders.mutex.RUnlock()

	return argCopy
}

// MinimockImportOrdersDone returns true if the count of the ImportOrders invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockImportOrdersDone() bool {
	if m.ImportOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImportOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImportOrdersMock.invocationsDone()
}

// MinimockImportOrdersInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockImportOrdersInspect() {
	for _, e := range m.ImportOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.ImportOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImportOrdersCounter := mm_atomic.LoadUint64(&m.afterImportOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImportOrdersMock.defaultExpectation != nil && afterImportOrdersCounter < 1 {
		if m.ImportOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.ImportOrders at\n%s", m.ImportOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.ImportOrders at\n%s with params: %#v", m.ImportOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ImportOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImportOrders != nil && afterImportOrdersCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.ImportOrders at\n%s", m.funcImportOrdersOrigin)
	}

	if !m.ImportOrdersMock.invocationsDone() && afterImportOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.ImportOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImportOrdersMock.expectedInvocations), m.ImportOrdersMock.expectedInvocationsOrigin, afterImportOrdersCounter)
	}
}

type mOrderServiceMockIssueOrders struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockIssueOrdersExpectation
	expectations       []*OrderServiceMockIssueOrdersExpectation

	callArgs []*OrderServiceMockIssueOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockIssueOrdersExpectation specifies expectation struct of the OrderService.IssueOrders
type OrderServiceMockIssueOrdersExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockIssueOrdersParams
	paramPtrs          *OrderServiceMockIssueOrdersParamPtrs
	expectationOrigins OrderServiceMockIssueOrdersExpectationOrigins
	results            *OrderServiceMockIssueOrdersResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockIssueOrdersParams contains parameters of the OrderService.IssueOrders
type OrderServiceMockIssueOrdersParams struct {
	ctx context.Context
	req requests.IssueOrdersRequest
}

// OrderServiceMockIssueOrdersParamPtrs contains pointers to parameters of the OrderService.IssueOrders
type OrderServiceMockIssueOrdersParamPtrs struct {
	ctx *context.Context
	req *requests.IssueOrdersRequest
}

// OrderServiceMockIssueOrdersResults contains results of the OrderService.IssueOrders
type OrderServiceMockIssueOrdersResults struct {
	ba1 []shared.BatchEntryProcessedResult
	err error
}

// OrderServiceMockIssueOrdersOrigins contains origins of expectations of the OrderService.IssueOrders
type OrderServiceMockIssueOrdersExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIssueOrders *mOrderServiceMockIssueOrders) Optional() *mOrderServiceMockIssueOrders {
	mmIssueOrders.optional = true
	return mmIssueOrders
}

// Expect sets up expected params for OrderService.IssueOrders
func (mmIssueOrders *mOrderServiceMockIssueOrders) Expect(ctx context.Context, req requests.IssueOrdersRequest) *mOrderServiceMockIssueOrders {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by Set")
	}

	if mmIssueOrders.defaultExpectation == nil {
		mmIssueOrders.defaultExpectation = &OrderServiceMockIssueOrdersExpectation{}
	}

	if mmIssueOrders.defaultExpectation.paramPtrs != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by ExpectParams functions")
	}

	mmIssueOrders.defaultExpectation.params = &OrderServiceMockIssueOrdersParams{ctx, req}
	mmIssueOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIssueOrders.expectations {
		if minimock.Equal(e.params, mmIssueOrders.defaultExpectation.params) {
			mmIssueOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueOrders.defaultExpectation.params)
		}
	}

	return mmIssueOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.IssueOrders
func (mmIssueOrders *mOrderServiceMockIssueOrders) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockIssueOrders {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by Set")
	}

	if mmIssueOrders.defaultExpectation == nil {
		mmIssueOrders.defaultExpectation = &OrderServiceMockIssueOrdersExpectation{}
	}

	if mmIssueOrders.defaultExpectation.params != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by Expect")
	}

	if mmIssueOrders.defaultExpectation.paramPtrs == nil {
		mmIssueOrders.defaultExpectation.paramPtrs = &OrderServiceMockIssueOrdersParamPtrs{}
	}
	mmIssueOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmIssueOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIssueOrders
}

// ExpectReqParam2 sets up expected param req for OrderService.IssueOrders
func (mmIssueOrders *mOrderServiceMockIssueOrders) ExpectReqParam2(req requests.IssueOrdersRequest) *mOrderServiceMockIssueOrders {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by Set")
	}

	if mmIssueOrders.defaultExpectation == nil {
		mmIssueOrders.defaultExpectation = &OrderServiceMockIssueOrdersExpectation{}
	}

	if mmIssueOrders.defaultExpectation.params != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by Expect")
	}

	if mmIssueOrders.defaultExpectation.paramPtrs == nil {
		mmIssueOrders.defaultExpectation.paramPtrs = &OrderServiceMockIssueOrdersParamPtrs{}
	}
	mmIssueOrders.defaultExpectation.paramPtrs.req = &req
	mmIssueOrders.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmIssueOrders
}

// Inspect accepts an inspector function that has same arguments as the OrderService.IssueOrders
func (mmIssueOrders *mOrderServiceMockIssueOrders) Inspect(f func(ctx context.Context, req requests.IssueOrdersRequest)) *mOrderServiceMockIssueOrders {
	if mmIssueOrders.mock.inspectFuncIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.IssueOrders")
	}

	mmIssueOrders.mock.inspectFuncIssueOrders = f

	return mmIssueOrders
}

// Return sets up results that will be returned by OrderService.IssueOrders
func (mmIssueOrders *mOrderServiceMockIssueOrders) Return(ba1 []shared.BatchEntryProcessedResult, err error) *OrderServiceMock {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by Set")
	}

	if mmIssueOrders.defaultExpectation == nil {
		mmIssueOrders.defaultExpectation = &OrderServiceMockIssueOrdersExpectation{mock: mmIssueOrders.mock}
	}
	mmIssueOrders.defaultExpectation.results = &OrderServiceMockIssueOrdersResults{ba1, err}
	mmIssueOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIssueOrders.mock
}

// Set uses given function f to mock the OrderService.IssueOrders method
func (mmIssueOrders *mOrderServiceMockIssueOrders) Set(f func(ctx context.Context, req requests.IssueOrdersRequest) (ba1 []shared.BatchEntryProcessedResult, err error)) *OrderServiceMock {
	if mmIssueOrders.defaultExpectation != nil {
		mmIssueOrders.mock.t.Fatalf("Default expectation is already set for the OrderService.IssueOrders method")
	}

	if len(mmIssueOrders.expectations) > 0 {
		mmIssueOrders.mock.t.Fatalf("Some expectations are already set for the OrderService.IssueOrders method")
	}

	mmIssueOrders.mock.funcIssueOrders = f
	mmIssueOrders.mock.funcIssueOrdersOrigin = minimock.CallerInfo(1)
	return mmIssueOrders.mock
}

// When sets expectation for the OrderService.IssueOrders which will trigger the result defined by the following
// Then helper
func (mmIssueOrders *mOrderServiceMockIssueOrders) When(ctx context.Context, req requests.IssueOrdersRequest) *OrderServiceMockIssueOrdersExpectation {
	if mmIssueOrders.mock.funcIssueOrders != nil {
		mmIssueOrders.mock.t.Fatalf("OrderServiceMock.IssueOrders mock is already set by Set")
	}

	expectation := &OrderServiceMockIssueOrdersExpectation{
		mock:               mmIssueOrders.mock,
		params:             &OrderServiceMockIssueOrdersParams{ctx, req},
		expectationOrigins: OrderServiceMockIssueOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIssueOrders.expectations = append(mmIssueOrders.expectations, expectation)
	return expectation
}

// Then sets up OrderService.IssueOrders return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockIssueOrdersExpectation) Then(ba1 []shared.BatchEntryProcessedResult, err error) *OrderServiceMock {
	e.results = &OrderServiceMockIssueOrdersResults{ba1, err}
	return e.mock
}

// Times sets number of times OrderService.IssueOrders should be invoked
func (mmIssueOrders *mOrderServiceMockIssueOrders) Times(n uint64) *mOrderServiceMockIssueOrders {
	if n == 0 {
		mmIssueOrders.mock.t.Fatalf("Times of OrderServiceMock.IssueOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIssueOrders.expectedInvocations, n)
	mmIssueOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIssueOrders
}

func (mmIssueOrders *mOrderServiceMockIssueOrders) invocationsDone() bool {
	if len(mmIssueOrders.expectations) == 0 && mmIssueOrders.defaultExpectation == nil && mmIssueOrders.mock.funcIssueOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIssueOrders.mock.afterIssueOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIssueOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IssueOrders implements mm_services.OrderService
func (mmIssueOrders *OrderServiceMock) IssueOrders(ctx context.Context, req requests.IssueOrdersRequest) (ba1 []shared.BatchEntryProcessedResult, err error) {
	mm_atomic.AddUint64(&mmIssueOrders.beforeIssueOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmIssueOrders.afterIssueOrdersCounter, 1)

	mmIssueOrders.t.Helper()

	if mmIssueOrders.inspectFuncIssueOrders != nil {
		mmIssueOrders.inspectFuncIssueOrders(ctx, req)
	}

	mm_params := OrderServiceMockIssueOrdersParams{ctx, req}

	// Record call args
	mmIssueOrders.IssueOrdersMock.mutex.Lock()
	mmIssueOrders.IssueOrdersMock.callArgs = append(mmIssueOrders.IssueOrdersMock.callArgs, &mm_params)
	mmIssueOrders.IssueOrdersMock.mutex.Unlock()

	for _, e := range mmIssueOrders.IssueOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmIssueOrders.IssueOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIssueOrders.IssueOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmIssueOrders.IssueOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmIssueOrders.IssueOrdersMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockIssueOrdersParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIssueOrders.t.Errorf("OrderServiceMock.IssueOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueOrders.IssueOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmIssueOrders.t.Errorf("OrderServiceMock.IssueOrders got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueOrders.IssueOrdersMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIssueOrders.t.Errorf("OrderServiceMock.IssueOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIssueOrders.IssueOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIssueOrders.IssueOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmIssueOrders.t.Fatal("No results are set for the OrderServiceMock.IssueOrders")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmIssueOrders.funcIssueOrders != nil {
		return mmIssueOrders.funcIssueOrders(ctx, req)
	}
	mmIssueOrders.t.Fatalf("Unexpected call to OrderServiceMock.IssueOrders. %v %v", ctx, req)
	return
}

// IssueOrdersAfterCounter returns a count of finished OrderServiceMock.IssueOrders invocations
func (mmIssueOrders *OrderServiceMock) IssueOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueOrders.afterIssueOrdersCounter)
}

// IssueOrdersBeforeCounter returns a count of OrderServiceMock.IssueOrders invocations
func (mmIssueOrders *OrderServiceMock) IssueOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueOrders.beforeIssueOrdersCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.IssueOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueOrders *mOrderServiceMockIssueOrders) Calls() []*OrderServiceMockIssueOrdersParams {
	mmIssueOrders.mutex.RLock()

	argCopy := make([]*OrderServiceMockIssueOrdersParams, len(mmIssueOrders.callArgs))
	copy(argCopy, mmIssueOrders.callArgs)

	mmIssueOrders.mutex.RUnlock()

	return argCopy
}

// MinimockIssueOrdersDone returns true if the count of the IssueOrders invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockIssueOrdersDone() bool {
	if m.IssueOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IssueOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IssueOrdersMock.invocationsDone()
}

// MinimockIssueOrdersInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockIssueOrdersInspect() {
	for _, e := range m.IssueOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.IssueOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIssueOrdersCounter := mm_atomic.LoadUint64(&m.afterIssueOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IssueOrdersMock.defaultExpectation != nil && afterIssueOrdersCounter < 1 {
		if m.IssueOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.IssueOrders at\n%s", m.IssueOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.IssueOrders at\n%s with params: %#v", m.IssueOrdersMock.defaultExpectation.expectationOrigins.origin, *m.IssueOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIssueOrders != nil && afterIssueOrdersCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.IssueOrders at\n%s", m.funcIssueOrdersOrigin)
	}

	if !m.IssueOrdersMock.invocationsDone() && afterIssueOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.IssueOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IssueOrdersMock.expectedInvocations), m.IssueOrdersMock.expectedInvocationsOrigin, afterIssueOrdersCounter)
	}
}

type mOrderServiceMockListOrders struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockListOrdersExpectation
	expectations       []*OrderServiceMockListOrdersExpectation

	callArgs []*OrderServiceMockListOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockListOrdersExpectation specifies expectation struct of the OrderService.ListOrders
type OrderServiceMockListOrdersExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockListOrdersParams
	paramPtrs          *OrderServiceMockListOrdersParamPtrs
	expectationOrigins OrderServiceMockListOrdersExpectationOrigins
	results            *OrderServiceMockListOrdersResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockListOrdersParams contains parameters of the OrderService.ListOrders
type OrderServiceMockListOrdersParams struct {
	ctx    context.Context
	filter requests.OrdersFilterRequest
}

// OrderServiceMockListOrdersParamPtrs contains pointers to parameters of the OrderService.ListOrders
type OrderServiceMockListOrdersParamPtrs struct {
	ctx    *context.Context
	filter *requests.OrdersFilterRequest
}

// OrderServiceMockListOrdersResults contains results of the OrderService.ListOrders
type OrderServiceMockListOrdersResults struct {
	oa1 []models.Order
	u1  uint64
	i1  int
	err error
}

// OrderServiceMockListOrdersOrigins contains origins of expectations of the OrderService.ListOrders
type OrderServiceMockListOrdersExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrders *mOrderServiceMockListOrders) Optional() *mOrderServiceMockListOrders {
	mmListOrders.optional = true
	return mmListOrders
}

// Expect sets up expected params for OrderService.ListOrders
func (mmListOrders *mOrderServiceMockListOrders) Expect(ctx context.Context, filter requests.OrdersFilterRequest) *mOrderServiceMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &OrderServiceMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.paramPtrs != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by ExpectParams functions")
	}

	mmListOrders.defaultExpectation.params = &OrderServiceMockListOrdersParams{ctx, filter}
	mmListOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.ListOrders
func (mmListOrders *mOrderServiceMockListOrders) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &OrderServiceMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &OrderServiceMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmListOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListOrders
}

// ExpectFilterParam2 sets up expected param filter for OrderService.ListOrders
func (mmListOrders *mOrderServiceMockListOrders) ExpectFilterParam2(filter requests.OrdersFilterRequest) *mOrderServiceMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &OrderServiceMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &OrderServiceMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.filter = &filter
	mmListOrders.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the OrderService.ListOrders
func (mmListOrders *mOrderServiceMockListOrders) Inspect(f func(ctx context.Context, filter requests.OrdersFilterRequest)) *mOrderServiceMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by OrderService.ListOrders
func (mmListOrders *mOrderServiceMockListOrders) Return(oa1 []models.Order, u1 uint64, i1 int, err error) *OrderServiceMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &OrderServiceMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &OrderServiceMockListOrdersResults{oa1, u1, i1, err}
	mmListOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// Set uses given function f to mock the OrderService.ListOrders method
func (mmListOrders *mOrderServiceMockListOrders) Set(f func(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, u1 uint64, i1 int, err error)) *OrderServiceMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the OrderService.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the OrderService.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	mmListOrders.mock.funcListOrdersOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// When sets expectation for the OrderService.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mOrderServiceMockListOrders) When(ctx context.Context, filter requests.OrdersFilterRequest) *OrderServiceMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderServiceMock.ListOrders mock is already set by Set")
	}

	expectation := &OrderServiceMockListOrdersExpectation{
		mock:               mmListOrders.mock,
		params:             &OrderServiceMockListOrdersParams{ctx, filter},
		expectationOrigins: OrderServiceMockListOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up OrderService.ListOrders return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockListOrdersExpectation) Then(oa1 []models.Order, u1 uint64, i1 int, err error) *OrderServiceMock {
	e.results = &OrderServiceMockListOrdersResults{oa1, u1, i1, err}
	return e.mock
}

// Times sets number of times OrderService.ListOrders should be invoked
func (mmListOrders *mOrderServiceMockListOrders) Times(n uint64) *mOrderServiceMockListOrders {
	if n == 0 {
		mmListOrders.mock.t.Fatalf("Times of OrderServiceMock.ListOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrders.expectedInvocations, n)
	mmListOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOrders
}

func (mmListOrders *mOrderServiceMockListOrders) invocationsDone() bool {
	if len(mmListOrders.expectations) == 0 && mmListOrders.defaultExpectation == nil && mmListOrders.mock.funcListOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrders.mock.afterListOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrders implements mm_services.OrderService
func (mmListOrders *OrderServiceMock) ListOrders(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, u1 uint64, i1 int, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	mmListOrders.t.Helper()

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx, filter)
	}

	mm_params := OrderServiceMockListOrdersParams{ctx, filter}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.u1, e.results.i1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmListOrders.ListOrdersMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockListOrdersParams{ctx, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrders.t.Errorf("OrderServiceMock.ListOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListOrders.t.Errorf("OrderServiceMock.ListOrders got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("OrderServiceMock.ListOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the OrderServiceMock.ListOrders")
		}
		return (*mm_results).oa1, (*mm_results).u1, (*mm_results).i1, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx, filter)
	}
	mmListOrders.t.Fatalf("Unexpected call to OrderServiceMock.ListOrders. %v %v", ctx, filter)
	return
}

// ListOrdersAfterCounter returns a count of finished OrderServiceMock.ListOrders invocations
func (mmListOrders *OrderServiceMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of OrderServiceMock.ListOrders invocations
func (mmListOrders *OrderServiceMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mOrderServiceMockListOrders) Calls() []*OrderServiceMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*OrderServiceMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockListOrdersDone() bool {
	if m.ListOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrdersMock.invocationsDone()
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.ListOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListOrdersCounter := mm_atomic.LoadUint64(&m.afterListOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && afterListOrdersCounter < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.ListOrders at\n%s", m.ListOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.ListOrders at\n%s with params: %#v", m.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && afterListOrdersCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.ListOrders at\n%s", m.funcListOrdersOrigin)
	}

	if !m.ListOrdersMock.invocationsDone() && afterListOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.ListOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrdersMock.expectedInvocations), m.ListOrdersMock.expectedInvocationsOrigin, afterListOrdersCounter)
	}
}

type mOrderServiceMockListReturns struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockListReturnsExpectation
	expectations       []*OrderServiceMockListReturnsExpectation

	callArgs []*OrderServiceMockListReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockListReturnsExpectation specifies expectation struct of the OrderService.ListReturns
type OrderServiceMockListReturnsExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockListReturnsParams
	paramPtrs          *OrderServiceMockListReturnsParamPtrs
	expectationOrigins OrderServiceMockListReturnsExpectationOrigins
	results            *OrderServiceMockListReturnsResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockListReturnsParams contains parameters of the OrderService.ListReturns
type OrderServiceMockListReturnsParams struct {
	ctx    context.Context
	filter requests.OrdersFilterRequest
}

// OrderServiceMockListReturnsParamPtrs contains pointers to parameters of the OrderService.ListReturns
type OrderServiceMockListReturnsParamPtrs struct {
	ctx    *context.Context
	filter *requests.OrdersFilterRequest
}

// OrderServiceMockListReturnsResults contains results of the OrderService.ListReturns
type OrderServiceMockListReturnsResults struct {
	oa1 []models.Order
	err error
}

// OrderServiceMockListReturnsOrigins contains origins of expectations of the OrderService.ListReturns
type OrderServiceMockListReturnsExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturns *mOrderServiceMockListReturns) Optional() *mOrderServiceMockListReturns {
	mmListReturns.optional = true
	return mmListReturns
}

// Expect sets up expected params for OrderService.ListReturns
func (mmListReturns *mOrderServiceMockListReturns) Expect(ctx context.Context, filter requests.OrdersFilterRequest) *mOrderServiceMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &OrderServiceMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.paramPtrs != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by ExpectParams functions")
	}

	mmListReturns.defaultExpectation.params = &OrderServiceMockListReturnsParams{ctx, filter}
	mmListReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListReturns.expectations {
		if minimock.Equal(e.params, mmListReturns.defaultExpectation.params) {
			mmListReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturns.defaultExpectation.params)
		}
	}

	return mmListReturns
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.ListReturns
func (mmListReturns *mOrderServiceMockListReturns) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &OrderServiceMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &OrderServiceMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListReturns
}

// ExpectFilterParam2 sets up expected param filter for OrderService.ListReturns
func (mmListReturns *mOrderServiceMockListReturns) ExpectFilterParam2(filter requests.OrdersFilterRequest) *mOrderServiceMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &OrderServiceMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &OrderServiceMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.filter = &filter
	mmListReturns.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListReturns
}

// Inspect accepts an inspector function that has same arguments as the OrderService.ListReturns
func (mmListReturns *mOrderServiceMockListReturns) Inspect(f func(ctx context.Context, filter requests.OrdersFilterRequest)) *mOrderServiceMockListReturns {
	if mmListReturns.mock.inspectFuncListReturns != nil {
		mmListReturns.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.ListReturns")
	}

	mmListReturns.mock.inspectFuncListReturns = f

	return mmListReturns
}

// Return sets up results that will be returned by OrderService.ListReturns
func (mmListReturns *mOrderServiceMockListReturns) Return(oa1 []models.Order, err error) *OrderServiceMock {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &OrderServiceMockListReturnsExpectation{mock: mmListReturns.mock}
	}
	mmListReturns.defaultExpectation.results = &OrderServiceMockListReturnsResults{oa1, err}
	mmListReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// Set uses given function f to mock the OrderService.ListReturns method
func (mmListReturns *mOrderServiceMockListReturns) Set(f func(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, err error)) *OrderServiceMock {
	if mmListReturns.defaultExpectation != nil {
		mmListReturns.mock.t.Fatalf("Default expectation is already set for the OrderService.ListReturns method")
	}

	if len(mmListReturns.expectations) > 0 {
		mmListReturns.mock.t.Fatalf("Some expectations are already set for the OrderService.ListReturns method")
	}

	mmListReturns.mock.funcListReturns = f
	mmListReturns.mock.funcListReturnsOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// When sets expectation for the OrderService.ListReturns which will trigger the result defined by the following
// Then helper
func (mmListReturns *mOrderServiceMockListReturns) When(ctx context.Context, filter requests.OrdersFilterRequest) *OrderServiceMockListReturnsExpectation {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("OrderServiceMock.ListReturns mock is already set by Set")
	}

	expectation := &OrderServiceMockListReturnsExpectation{
		mock:               mmListReturns.mock,
		params:             &OrderServiceMockListReturnsParams{ctx, filter},
		expectationOrigins: OrderServiceMockListReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListReturns.expectations = append(mmListReturns.expectations, expectation)
	return expectation
}

// Then sets up OrderService.ListReturns return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockListReturnsExpectation) Then(oa1 []models.Order, err error) *OrderServiceMock {
	e.results = &OrderServiceMockListReturnsResults{oa1, err}
	return e.mock
}

// Times sets number of times OrderService.ListReturns should be invoked
func (mmListReturns *mOrderServiceMockListReturns) Times(n uint64) *mOrderServiceMockListReturns {
	if n == 0 {
		mmListReturns.mock.t.Fatalf("Times of OrderServiceMock.ListReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReturns.expectedInvocations, n)
	mmListReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListReturns
}

func (mmListReturns *mOrderServiceMockListReturns) invocationsDone() bool {
	if len(mmListReturns.expectations) == 0 && mmListReturns.defaultExpectation == nil && mmListReturns.mock.funcListReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReturns.mock.afterListReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReturns implements mm_services.OrderService
func (mmListReturns *OrderServiceMock) ListReturns(ctx context.Context, filter requests.OrdersFilterRequest) (oa1 []models.Order, err error) {
	mm_atomic.AddUint64(&mmListReturns.beforeListReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturns.afterListReturnsCounter, 1)

	mmListReturns.t.Helper()

	if mmListReturns.inspectFuncListReturns != nil {
		mmListReturns.inspectFuncListReturns(ctx, filter)
	}

	mm_params := OrderServiceMockListReturnsParams{ctx, filter}

	// Record call args
	mmListReturns.ListReturnsMock.mutex.Lock()
	mmListReturns.ListReturnsMock.callArgs = append(mmListReturns.ListReturnsMock.callArgs, &mm_params)
	mmListReturns.ListReturnsMock.mutex.Unlock()

	for _, e := range mmListReturns.ListReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListReturns.ListReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturns.ListReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturns.ListReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmListReturns.ListReturnsMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockListReturnsParams{ctx, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReturns.t.Errorf("OrderServiceMock.ListReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListReturns.t.Errorf("OrderServiceMock.ListReturns got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturns.t.Errorf("OrderServiceMock.ListReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturns.ListReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturns.t.Fatal("No results are set for the OrderServiceMock.ListReturns")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListReturns.funcListReturns != nil {
		return mmListReturns.funcListReturns(ctx, filter)
	}
	mmListReturns.t.Fatalf("Unexpected call to OrderServiceMock.ListReturns. %v %v", ctx, filter)
	return
}

// ListReturnsAfterCounter returns a count of finished OrderServiceMock.ListReturns invocations
func (mmListReturns *OrderServiceMock) ListReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.afterListReturnsCounter)
}

// ListReturnsBeforeCounter returns a count of OrderServiceMock.ListReturns invocations
func (mmListReturns *OrderServiceMock) ListReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.beforeListReturnsCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.ListReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturns *mOrderServiceMockListReturns) Calls() []*OrderServiceMockListReturnsParams {
	mmListReturns.mutex.RLock()

	argCopy := make([]*OrderServiceMockListReturnsParams, len(mmListReturns.callArgs))
	copy(argCopy, mmListReturns.callArgs)

	mmListReturns.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnsDone returns true if the count of the ListReturns invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockListReturnsDone() bool {
	if m.ListReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReturnsMock.invocationsDone()
}

// MinimockListReturnsInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockListReturnsInspect() {
	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.ListReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListReturnsCounter := mm_atomic.LoadUint64(&m.afterListReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnsMock.defaultExpectation != nil && afterListReturnsCounter < 1 {
		if m.ListReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.ListReturns at\n%s", m.ListReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.ListReturns at\n%s with params: %#v", m.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *m.ListReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturns != nil && afterListReturnsCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.ListReturns at\n%s", m.funcListReturnsOrigin)
	}

	if !m.ListReturnsMock.invocationsDone() && afterListReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.ListReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListReturnsMock.expectedInvocations), m.ListReturnsMock.expectedInvocationsOrigin, afterListReturnsCounter)
	}
}

type mOrderServiceMockReturnToCourier struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockReturnToCourierExpectation
	expectations       []*OrderServiceMockReturnToCourierExpectation

	callArgs []*OrderServiceMockReturnToCourierParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderServiceMockReturnToCourierExpectation specifies expectation struct of the OrderService.ReturnToCourier
type OrderServiceMockReturnToCourierExpectation struct {
	mock               *OrderServiceMock
	params             *OrderServiceMockReturnToCourierParams
	paramPtrs          *OrderServiceMockReturnToCourierParamPtrs
	expectationOrigins OrderServiceMockReturnToCourierExpectationOrigins
	results            *OrderServiceMockReturnToCourierResults
	returnOrigin       string
	Counter            uint64
}

// OrderServiceMockReturnToCourierParams contains parameters of the OrderService.ReturnToCourier
type OrderServiceMockReturnToCourierParams struct {
	ctx context.Context
	req requests.ReturnOrderRequest
}

// OrderServiceMockReturnToCourierParamPtrs contains pointers to parameters of the OrderService.ReturnToCourier
type OrderServiceMockReturnToCourierParamPtrs struct {
	ctx *context.Context
	req *requests.ReturnOrderRequest
}

// OrderServiceMockReturnToCourierResults contains results of the OrderService.ReturnToCourier
type OrderServiceMockReturnToCourierResults struct {
	err error
}

// OrderServiceMockReturnToCourierOrigins contains origins of expectations of the OrderService.ReturnToCourier
type OrderServiceMockReturnToCourierExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) Optional() *mOrderServiceMockReturnToCourier {
	mmReturnToCourier.optional = true
	return mmReturnToCourier
}

// Expect sets up expected params for OrderService.ReturnToCourier
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) Expect(ctx context.Context, req requests.ReturnOrderRequest) *mOrderServiceMockReturnToCourier {
	if mmReturnToCourier.mock.funcReturnToCourier != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by Set")
	}

	if mmReturnToCourier.defaultExpectation == nil {
		mmReturnToCourier.defaultExpectation = &OrderServiceMockReturnToCourierExpectation{}
	}

	if mmReturnToCourier.defaultExpectation.paramPtrs != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by ExpectParams functions")
	}

	mmReturnToCourier.defaultExpectation.params = &OrderServiceMockReturnToCourierParams{ctx, req}
	mmReturnToCourier.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReturnToCourier.expectations {
		if minimock.Equal(e.params, mmReturnToCourier.defaultExpectation.params) {
			mmReturnToCourier.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnToCourier.defaultExpectation.params)
		}
	}

	return mmReturnToCourier
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.ReturnToCourier
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockReturnToCourier {
	if mmReturnToCourier.mock.funcReturnToCourier != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by Set")
	}

	if mmReturnToCourier.defaultExpectation == nil {
		mmReturnToCourier.defaultExpectation = &OrderServiceMockReturnToCourierExpectation{}
	}

	if mmReturnToCourier.defaultExpectation.params != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by Expect")
	}

	if mmReturnToCourier.defaultExpectation.paramPtrs == nil {
		mmReturnToCourier.defaultExpectation.paramPtrs = &OrderServiceMockReturnToCourierParamPtrs{}
	}
	mmReturnToCourier.defaultExpectation.paramPtrs.ctx = &ctx
	mmReturnToCourier.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReturnToCourier
}

// ExpectReqParam2 sets up expected param req for OrderService.ReturnToCourier
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) ExpectReqParam2(req requests.ReturnOrderRequest) *mOrderServiceMockReturnToCourier {
	if mmReturnToCourier.mock.funcReturnToCourier != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by Set")
	}

	if mmReturnToCourier.defaultExpectation == nil {
		mmReturnToCourier.defaultExpectation = &OrderServiceMockReturnToCourierExpectation{}
	}

	if mmReturnToCourier.defaultExpectation.params != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by Expect")
	}

	if mmReturnToCourier.defaultExpectation.paramPtrs == nil {
		mmReturnToCourier.defaultExpectation.paramPtrs = &OrderServiceMockReturnToCourierParamPtrs{}
	}
	mmReturnToCourier.defaultExpectation.paramPtrs.req = &req
	mmReturnToCourier.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmReturnToCourier
}

// Inspect accepts an inspector function that has same arguments as the OrderService.ReturnToCourier
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) Inspect(f func(ctx context.Context, req requests.ReturnOrderRequest)) *mOrderServiceMockReturnToCourier {
	if mmReturnToCourier.mock.inspectFuncReturnToCourier != nil {
		mmReturnToCourier.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.ReturnToCourier")
	}

	mmReturnToCourier.mock.inspectFuncReturnToCourier = f

	return mmReturnToCourier
}

// Return sets up results that will be returned by OrderService.ReturnToCourier
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) Return(err error) *OrderServiceMock {
	if mmReturnToCourier.mock.funcReturnToCourier != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by Set")
	}

	if mmReturnToCourier.defaultExpectation == nil {
		mmReturnToCourier.defaultExpectation = &OrderServiceMockReturnToCourierExpectation{mock: mmReturnToCourier.mock}
	}
	mmReturnToCourier.defaultExpectation.results = &OrderServiceMockReturnToCourierResults{err}
	mmReturnToCourier.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReturnToCourier.mock
}

// Set uses given function f to mock the OrderService.ReturnToCourier method
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) Set(f func(ctx context.Context, req requests.ReturnOrderRequest) (err error)) *OrderServiceMock {
	if mmReturnToCourier.defaultExpectation != nil {
		mmReturnToCourier.mock.t.Fatalf("Default expectation is already set for the OrderService.ReturnToCourier method")
	}

	if len(mmReturnToCourier.expectations) > 0 {
		mmReturnToCourier.mock.t.Fatalf("Some expectations are already set for the OrderService.ReturnToCourier method")
	}

	mmReturnToCourier.mock.funcReturnToCourier = f
	mmReturnToCourier.mock.funcReturnToCourierOrigin = minimock.CallerInfo(1)
	return mmReturnToCourier.mock
}

// When sets expectation for the OrderService.ReturnToCourier which will trigger the result defined by the following
// Then helper
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) When(ctx context.Context, req requests.ReturnOrderRequest) *OrderServiceMockReturnToCourierExpectation {
	if mmReturnToCourier.mock.funcReturnToCourier != nil {
		mmReturnToCourier.mock.t.Fatalf("OrderServiceMock.ReturnToCourier mock is already set by Set")
	}

	expectation := &OrderServiceMockReturnToCourierExpectation{
		mock:               mmReturnToCourier.mock,
		params:             &OrderServiceMockReturnToCourierParams{ctx, req},
		expectationOrigins: OrderServiceMockReturnToCourierExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReturnToCourier.expectations = append(mmReturnToCourier.expectations, expectation)
	return expectation
}

// Then sets up OrderService.ReturnToCourier return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockReturnToCourierExpectation) Then(err error) *OrderServiceMock {
	e.results = &OrderServiceMockReturnToCourierResults{err}
	return e.mock
}

// Times sets number of times OrderService.ReturnToCourier should be invoked
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) Times(n uint64) *mOrderServiceMockReturnToCourier {
	if n == 0 {
		mmReturnToCourier.mock.t.Fatalf("Times of OrderServiceMock.ReturnToCourier mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReturnToCourier.expectedInvocations, n)
	mmReturnToCourier.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReturnToCourier
}

func (mmReturnToCourier *mOrderServiceMockReturnToCourier) invocationsDone() bool {
	if len(mmReturnToCourier.expectations) == 0 && mmReturnToCourier.defaultExpectation == nil && mmReturnToCourier.mock.funcReturnToCourier == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReturnToCourier.mock.afterReturnToCourierCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReturnToCourier.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReturnToCourier implements mm_services.OrderService
func (mmReturnToCourier *OrderServiceMock) ReturnToCourier(ctx context.Context, req requests.ReturnOrderRequest) (err error) {
	mm_atomic.AddUint64(&mmReturnToCourier.beforeReturnToCourierCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnToCourier.afterReturnToCourierCounter, 1)

	mmReturnToCourier.t.Helper()

	if mmReturnToCourier.inspectFuncReturnToCourier != nil {
		mmReturnToCourier.inspectFuncReturnToCourier(ctx, req)
	}

	mm_params := OrderServiceMockReturnToCourierParams{ctx, req}

	// Record call args
	mmReturnToCourier.ReturnToCourierMock.mutex.Lock()
	mmReturnToCourier.ReturnToCourierMock.callArgs = append(mmReturnToCourier.ReturnToCourierMock.callArgs, &mm_params)
	mmReturnToCourier.ReturnToCourierMock.mutex.Unlock()

	for _, e := range mmReturnToCourier.ReturnToCourierMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturnToCourier.ReturnToCourierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnToCourier.ReturnToCourierMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnToCourier.ReturnToCourierMock.defaultExpectation.params
		mm_want_ptrs := mmReturnToCourier.ReturnToCourierMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockReturnToCourierParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReturnToCourier.t.Errorf("OrderServiceMock.ReturnToCourier got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReturnToCourier.ReturnToCourierMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmReturnToCourier.t.Errorf("OrderServiceMock.ReturnToCourier got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReturnToCourier.ReturnToCourierMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnToCourier.t.Errorf("OrderServiceMock.ReturnToCourier got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReturnToCourier.ReturnToCourierMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnToCourier.ReturnToCourierMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnToCourier.t.Fatal("No results are set for the OrderServiceMock.ReturnToCourier")
		}
		return (*mm_results).err
	}
	if mmReturnToCourier.funcReturnToCourier != nil {
		return mmReturnToCourier.funcReturnToCourier(ctx, req)
	}
	mmReturnToCourier.t.Fatalf("Unexpected call to OrderServiceMock.ReturnToCourier. %v %v", ctx, req)
	return
}

// ReturnToCourierAfterCounter returns a count of finished OrderServiceMock.ReturnToCourier invocations
func (mmReturnToCourier *OrderServiceMock) ReturnToCourierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnToCourier.afterReturnToCourierCounter)
}

// ReturnToCourierBeforeCounter returns a count of OrderServiceMock.ReturnToCourier invocations
func (mmReturnToCourier *OrderServiceMock) ReturnToCourierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnToCourier.beforeReturnToCourierCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.ReturnToCourier.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnToCourier *mOrderServiceMockReturnToCourier) Calls() []*OrderServiceMockReturnToCourierParams {
	mmReturnToCourier.mutex.RLock()

	argCopy := make([]*OrderServiceMockReturnToCourierParams, len(mmReturnToCourier.callArgs))
	copy(argCopy, mmReturnToCourier.callArgs)

	mmReturnToCourier.mutex.RUnlock()

	return argCopy
}

// MinimockReturnToCourierDone returns true if the count of the ReturnToCourier invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockReturnToCourierDone() bool {
	if m.ReturnToCourierMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReturnToCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReturnToCourierMock.invocationsDone()
}

// MinimockReturnToCourierInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockReturnToCourierInspect() {
	for _, e := range m.ReturnToCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.ReturnToCourier at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReturnToCourierCounter := mm_atomic.LoadUint64(&m.afterReturnToCourierCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnToCourierMock.defaultExpectation != nil && afterReturnToCourierCounter < 1 {
		if m.ReturnToCourierMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderServiceMock.ReturnToCourier at\n%s", m.ReturnToCourierMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.ReturnToCourier at\n%s with params: %#v", m.ReturnToCourierMock.defaultExpectation.expectationOrigins.origin, *m.ReturnToCourierMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnToCourier != nil && afterReturnToCourierCounter < 1 {
		m.t.Errorf("Expected call to OrderServiceMock.ReturnToCourier at\n%s", m.funcReturnToCourierOrigin)
	}

	if !m.ReturnToCourierMock.invocationsDone() && afterReturnToCourierCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.ReturnToCourier at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReturnToCourierMock.expectedInvocations), m.ReturnToCourierMock.expectedInvocationsOrigin, afterReturnToCourierCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptOrderInspect()

			m.MinimockCreateClientReturnsInspect()

			m.MinimockImportOrdersInspect()

			m.MinimockIssueOrdersInspect()

			m.MinimockListOrdersInspect()

			m.MinimockListReturnsInspect()

			m.MinimockReturnToCourierInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptOrderDone() &&
		m.MinimockCreateClientReturnsDone() &&
		m.MinimockImportOrdersDone() &&
		m.MinimockIssueOrdersDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockListReturnsDone() &&
		m.MinimockReturnToCourierDone()
}
